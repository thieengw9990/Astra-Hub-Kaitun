-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Player Variables
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")
local Mouse = Player:GetMouse()

-- Settings Configuration
local Settings = {
    -- Auto Farm
    AutoFarm = false,
    AutoAttack = false,
    FarmRange = 500,
    SelectedMob = "",
    MobPriority = "Nearest",
    FarmOnlySelected = false,
    
    -- Levi Settings
    AutoLevi = false,
    LeviSkillDelay = 1,
    UseLeviDash = true,
    UseLeviSpin = true,
    UseLeviFlight = true,
    
    -- Boat Settings
    AutoBoat = false,
    AutoSpawnBoat = false,
    BoatSpeed = 100,
    BoatDestination = "Tiki Island",
    FollowSeaBeasts = false,
    AutoDock = true,
    
    -- Auto Buy
    AutoBuyLeviChip = false,
    AutoBuySwords = false,
    AutoBuyFruits = false,
    AutoBuyAccessories = false,
    BuyOnlyBest = true,
    
    -- Levi Raid
    AutoLeviRaid = false,
    LeviRaidStage = 1,
    AutoCollectLeviHearts = false,
    UseSpawnBoatRaid = true,
    
    -- Combat
    AutoDodge = true,
    AutoBlock = true,
    UseM1Combo = true,
    UseSkillsCombo = true,
    CombatMode = "Balanced",
    
    -- Player
    WalkSpeed = 16,
    JumpPower = 50,
    NoClip = false,
    InfiniteEnergy = false,
    GodMode = false,
    
    -- Server
    AutoRejoin = false,
    AutoJoinDelay = 5,
    ServerHopOnLowPlayers = false,
    MinimumPlayers = 5,
    
    -- UI
    UITheme = "Dark",
    UISize = 1,
    SaveSettings = true,
    
    -- Misc
    AutoCollectChests = false,
    AutoCollectFruits = false,
    AntiAfk = true,
    HideUsername = false,
    AutoSell = false,
    
    -- Tiki/Hydra Island
    AutoTikiIsland = false,
    AutoHydraIsland = false,
    IslandFarmMode = "Mobs",
    CollectTikiTotems = true,
    CollectHydraScales = true,
    
    -- Advanced
    ESPEnabled = false,
    ESPMobs = true,
    ESPChests = true,
    ESPFruits = true,
    ESPPlayers = false,
    
    -- Performance
    RenderDistance = 1000,
    RemoveEffects = false,
    LowGraphics = false
}

-- Global Variables
local Boats = {}
local CurrentBoat = nil
local LeviRaidActive = false
local TikiIslandActive = false
local HydraIslandActive = false
local SeaBeastTarget = nil
local IslandWaypoints = {}
local FarmLoop = nil
local LeviLoop = nil
local BoatLoop = nil
local RaidLoop = nil
local IslandLoop = nil
local ESPObjects = {}

-- Island Locations Database
local IslandLocations = {
    ["Tiki Island"] = {
        Position = Vector3.new(59387, 39, 2515),
        BoatSpawn = Vector3.new(57654, 4, 2515),
        DockPosition = Vector3.new(58654, 4, 2515),
        Mobs = {"Tiki Warrior", "Tiki Brute", "Tiki Chief"},
        Boss = "Tiki King",
        BossPosition = Vector3.new(59800, 100, 2515),
        Chests = {"Tiki Chest", "Ancient Tiki Chest"},
        Totems = {"Tiki Totem", "Ancient Totem"},
        Resources = {"Tiki Wood", "Tiki Stone", "Sacred Gem"}
    },
    
    ["Hydra Island"] = {
        Position = Vector3.new(5730, 135, -11300),
        BoatSpawn = Vector3.new(4600, 4, -10500),
        DockPosition = Vector3.new(5100, 4, -10900),
        Mobs = {"Hydra Scout", "Hydra Warrior", "Hydra Elite"},
        Boss = "Hydra Queen",
        BossPosition = Vector3.new(5800, 200, -11300),
        Chests = {"Hydra Chest", "Deep Sea Chest"},
        Scales = {"Hydra Scale", "Queen Scale"},
        Resources = {"Sea Coral", "Deep Pearl", "Abyssal Stone"}
    },
    
    ["Shark Island"] = {
        Position = Vector3.new(-4554, 51, -4400),
        BoatSpawn = Vector3.new(-4000, 4, -3800),
        DockPosition = Vector3.new(-4254, 4, -4100),
        Mobs = {"Shark Soldier", "Shark Captain", "Shark General"},
        Boss = "Shark King",
        BossPosition = Vector3.new(-4654, 100, -4400)
    },
    
    ["Frozen Island"] = {
        Position = Vector3.new(1191, 48, -1410),
        BoatSpawn = Vector3.new(1500, 4, -1200),
        DockPosition = Vector3.new(1300, 4, -1300),
        Mobs = {"Ice Warrior", "Frozen Brute", "Ice King Guard"},
        Boss = "Ice King",
        BossPosition = Vector3.new(1191, 100, -1410)
    },
    
    ["Desert Island"] = {
        Position = Vector3.new(1089, 48, 4182),
        BoatSpawn = Vector3.new(2000, 4, 3800),
        DockPosition = Vector3.new(1500, 4, 4000),
        Mobs = {"Desert Bandit", "Desert Warrior", "Desert King Guard"},
        Boss = "Desert King",
        BossPosition = Vector3.new(1089, 100, 4182)
    }
}

-- Levi Skills Database
local LeviSkills = {
    ["Levi Dash"] = {
        Key = "Z",
        Cooldown = 5,
        Damage = 2500,
        Range = 100,
        Type = "Movement/Attack",
        Description = "Dash forward dealing damage to enemies"
    },
    
    ["Levi Spin"] = {
        Key = "X",
        Cooldown = 8,
        Damage = 3500,
        Range = 50,
        Type = "AoE Attack",
        Description = "Spin attack that hits multiple enemies"
    },
    
    ["Levi Flight"] = {
        Key = "C",
        Cooldown = 12,
        Damage = 2000,
        Range = 75,
        Type = "Movement/Attack",
        Description = "Fly upward and slam down"
    },
    
    ["Levi Vortex"] = {
        Key = "V",
        Cooldown = 15,
        Damage = 5000,
        Range = 80,
        Type = "AoE Attack",
        Description = "Create a vortex pulling enemies in"
    },
    
    ["Levi Tsunami"] = {
        Key = "F",
        Cooldown = 30,
        Damage = 10000,
        Range = 150,
        Type = "Ultimate",
        Description = "Summon a massive tsunami wave"
    }
}

-- Mob Priority Database
local MobPriorityList = {
    ["Highest Level"] = function(a, b)
        return (a:GetAttribute("Level") or 0) > (b:GetAttribute("Level") or 0)
    end,
    
    ["Lowest Level"] = function(a, b)
        return (a:GetAttribute("Level") or 0) < (b:GetAttribute("Level") or 0)
    end,
    
    ["Nearest"] = function(a, b, playerPos)
        local distA = (a.HumanoidRootPart.Position - playerPos).Magnitude
        local distB = (b.HumanoidRootPart.Position - playerPos).Magnitude
        return distA < distB
    end,
    
    ["Highest Health"] = function(a, b)
        return a.Humanoid.Health > b.Humanoid.Health
    end,
    
    ["Lowest Health"] = function(a, b)
        return a.Humanoid.Health < b.Humanoid.Health
    end,
    
    ["Boss Priority"] = function(a, b)
        local isBossA = a.Name:find("Boss") or a.Name:find("King") or a.Name:find("Queen")
        local isBossB = b.Name:find("Boss") or b.Name:find("King") or b.Name:find("Queen")
        if isBossA and not isBossB then return true end
        if not isBossA and isBossB then return false end
        return (a:GetAttribute("Level") or 0) > (b:GetAttribute("Level") or 0)
    end
}

-- Auto Buy Items Database
local BuyableItems = {
    ["Levi Chip"] = {
        Location = "Leviathan NPC",
        Position = Vector3.new(-4588, 73, -253),
        Price = 1000000,
        Type = "Chip",
        Requirement = "Level 1000+"
    },
    
    ["Cutlass"] = {
        Location = "Sword Dealer",
        Position = Vector3.new(-1258, 18, 398),
        Price = 1000,
        Type = "Sword",
        Requirement = "None"
    },
    
    ["Katana"] = {
        Location = "Sword Dealer",
        Position = Vector3.new(-1258, 18, 398),
        Price = 10000,
        Type = "Sword",
        Requirement = "None"
    },
    
    ["Iron Mace"] = {
        Location = "Sword Dealer",
        Position = Vector3.new(-1258, 18, 398),
        Price = 25000,
        Type = "Sword",
        Requirement = "None"
    },
    
    ["Dual Katana"] = {
        Location = "Legendary Sword Dealer",
        Position = Vector3.new(-4954, 331, -2977),
        Price = 1200000,
        Type = "Sword",
        Requirement = "Level 800+"
    },
    
    ["Bomb Fruit"] = {
        Location = "Blox Fruit Dealer",
        Position = Vector3.new(-604, 25, -475),
        Price = 50000,
        Type = "Fruit",
        Requirement = "None"
    },
    
    ["Spike Fruit"] = {
        Location = "Blox Fruit Dealer",
        Position = Vector3.new(-604, 25, -475),
        Price = 100000,
        Type = "Fruit",
        Requirement = "None"
    },
    
    ["Leviathan Helmet"] = {
        Location = "Leviathan Armory",
        Position = Vector3.new(-4600, 73, -250),
        Price = 500000,
        Type = "Accessory",
        Requirement = "Levi Chip"
    },
    
    ["Leviathan Armor"] = {
        Location = "Leviathan Armory",
        Position = Vector3.new(-4600, 73, -250),
        Price = 750000,
        Type = "Accessory",
        Requirement = "Levi Chip"
    }
}

-- Initialize Orion Lib (Astra Hub)
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Colors = {
    Main = Color3.fromRGB(45, 45, 45),
    Second = Color3.fromRGB(30, 30, 30),
    Third = Color3.fromRGB(25, 25, 25),
    Accent = Color3.fromRGB(0, 170, 255),
    Text = Color3.fromRGB(255, 255, 255),
    Success = Color3.fromRGB(0, 255, 127),
    Warning = Color3.fromRGB(255, 165, 0),
    Error = Color3.fromRGB(255, 50, 50)
}

local Window = OrionLib:MakeWindow({
    Name = "Astra Hub | Leviathan",
    HidePremium = false,
    SaveConfig = Settings.SaveSettings,
    ConfigFolder = "By White",
    IntroEnabled = true,
    IntroText = "LEVI Kaitun",
    IntroIcon = "http://www.roblox.com/asset/?id=118487191387654",
    Icon = "http://www.roblox.com/asset/?id=118487191387654"
})

-- Utility Functions
function Notify(Title, Content, Duration)
    OrionLib:MakeNotification({
        Name = Title,
        Content = Content,
        Image = "http://www.roblox.com/asset/?id=118487191387654",
        Time = Duration or 5
    })
end

function WaitForChild(parent, childName, timeout)
    timeout = timeout or 10
    local startTime = tick()
    while tick() - startTime < timeout do
        if parent:FindFirstChild(childName) then
            return parent[childName]
        end
        task.wait(0.1)
    end
    return nil
end

function GetPlayerLevel()
    local leaderstats = Player:FindFirstChild("leaderstats")
    if leaderstats then
        local level = leaderstats:FindFirstChild("Level")
        if level then
            return level.Value
        end
    end
    return 0
end

function GetPlayerBeli()
    local leaderstats = Player:FindFirstChild("leaderstats")
    if leaderstats then
        local beli = leaderstats:FindFirstChild("Beli")
        if beli then
            return beli.Value
        end
    end
    return 0
end

function IsPlayerInIsland()
    for islandName, islandData in pairs(IslandLocations) do
        local distance = (HumanoidRootPart.Position - islandData.Position).Magnitude
        if distance < 500 then
            return true, islandName
        end
    end
    return false, ""
end

function GetNearestBoat()
    local nearestBoat = nil
    local shortestDistance = math.huge
    
    for _, boat in pairs(Workspace:GetChildren()) do
        if boat.Name:find("Boat") or boat.Name:find("Ship") then
            if boat:FindFirstChild("Main") then
                local distance = (HumanoidRootPart.Position - boat.Main.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestBoat = boat
                end
            end
        end
    end
    
    return nearestBoat
end

function SpawnBoat()
    -- TÃ¬m boat spawner
    local boatSpawners = {}
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name:find("Boat") and obj:FindFirstChild("Click") then
            table.insert(boatSpawners, obj)
        end
    end
    
    if #boatSpawners > 0 then
        local nearestSpawner = boatSpawners[1]
        local shortestDistance = math.huge
        
        for _, spawner in pairs(boatSpawners) do
            local distance = (HumanoidRootPart.Position - spawner.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestSpawner = spawner
            end
        end
        
        -- Teleport Ä‘áº¿n spawner
        HumanoidRootPart.CFrame = CFrame.new(nearestSpawner.Position)
        task.wait(0.5)
        
        -- Click spawner
        fireclickdetector(nearestSpawner.Click)
        Notify("Boat System", "Boat spawned successfully!", 3)
        return true
    end
    
    Notify("Boat System", "No boat spawner found!", 3)
    return false
end

function DriveBoatToIsland(islandName)
    if not IslandLocations[islandName] then
        Notify("Navigation Error", "Island not found: " .. islandName, 3)
        return false
    end
    
    local islandData = IslandLocations[islandName]
    local boat = GetNearestBoat()
    
    if not boat then
        Notify("Navigation Error", "No boat found nearby!", 3)
        return false
    end
    
    -- Enter boat
    if boat:FindFirstChild("VehicleSeat") then
        HumanoidRootPart.CFrame = CFrame.new(boat.VehicleSeat.Position)
        task.wait(0.5)
        fireproximityprompt(boat.VehicleSeat.Enter)
    end
    
    -- Set boat as current
    CurrentBoat = boat
    Settings.AutoBoat = true
    Settings.BoatDestination = islandName
    
    Notify("Navigation", "Driving to " .. islandName .. "...", 3)
    return true
end

function AutoBuyItem(itemName)
    if not BuyableItems[itemName] then
        Notify("Auto Buy", "Item not found: " .. itemName, 3)
        return false
    end
    
    local itemData = BuyableItems[itemName]
    local playerBeli = GetPlayerBeli()
    
    if playerBeli < itemData.Price then
        Notify("Auto Buy", "Not enough Beli! Need: " .. itemData.Price, 3)
        return false
    end
    
    -- Teleport to NPC
    local originalPosition = HumanoidRootPart.Position
    HumanoidRootPart.CFrame = CFrame.new(itemData.Position)
    task.wait(2)
    
    -- Find NPC and click
    local npc = nil
    for _, obj in pairs(Workspace.NPCs:GetChildren()) do
        if obj.Name:find(itemData.Location) then
            npc = obj
            break
        end
    end
    
    if npc and npc:FindFirstChild("Click") then
        fireclickdetector(npc.Click)
        task.wait(1)
        
        -- Try to buy (simulate GUI interaction)
        game:GetService("VirtualInputManager"):SendKeyEvent(true, "E", false, game)
        task.wait(0.1)
        game:GetService("VirtualInputManager"):SendKeyEvent(false, "E", false, game)
        
        Notify("Auto Buy", "Purchased: " .. itemName, 3)
        
        -- Return to original position
        task.wait(2)
        HumanoidRootPart.CFrame = CFrame.new(originalPosition)
        
        return true
    else
        Notify("Auto Buy", "NPC not found: " .. itemData.Location, 3)
        HumanoidRootPart.CFrame = CFrame.new(originalPosition)
        return false
    end
end

-- Initialize tabs
local MainTab = Window:MakeTab({
    Name = "ðŸ  Main",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local LeviTab = Window:MakeTab({
    Name = "ðŸŒ€ Levi",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local BoatTab = Window:MakeTab({
    Name = "â›µ Boat",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local IslandTab = Window:MakeTab({
    Name = "ðŸï¸ Islands",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local AutoBuyTab = Window:MakeTab({
    Name = "ðŸ›’ Auto Buy",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local RaidTab = Window:MakeTab({
    Name = "âš”ï¸ Raid",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local CombatTab = Window:MakeTab({
    Name = "âš”ï¸ Combat",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local PlayerTab = Window:MakeTab({
    Name = "ðŸ‘¤ Player",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local ServerTab = Window:MakeTab({
    Name = "ðŸŒ Server",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

local SettingsTab = Window:MakeTab({
    Name = "âš™ï¸ Settings",
    Icon = "http://www.roblox.com/asset/?id=6023426923",
    PremiumOnly = false
})

-- Main Tab Content
MainTab:AddSection({
    Name = "Auto Farm System"
})

MainTab:AddToggle({
    Name = "Auto Farm",
    Default = false,
    Callback = function(Value)
        Settings.AutoFarm = Value
        if Value then
            StartAutoFarm()
        else
            StopAutoFarm()
        end
    end
})

MainTab:AddToggle({
    Name = "Auto Attack",
    Default = false,
    Callback = function(Value)
        Settings.AutoAttack = Value
    end
})

MainTab:AddSlider({
    Name = "Farm Range",
    Min = 10,
    Max = 1000,
    Default = 500,
    Color = Colors.Accent,
    Increment = 10,
    ValueName = "studs",
    Callback = function(Value)
        Settings.FarmRange = Value
    end
})

MainTab:AddDropdown({
    Name = "Mob Priority",
    Default = "Nearest",
    Options = {"Nearest", "Highest Level", "Lowest Level", "Highest Health", "Lowest Health", "Boss Priority"},
    Callback = function(Value)
        Settings.MobPriority = Value
    end
})

MainTab:AddTextbox({
    Name = "Specific Mob",
    Default = "",
    TextDisappear = true,
    Callback = function(Value)
        Settings.SelectedMob = Value
    end
})

MainTab:AddToggle({
    Name = "Farm Only Selected",
    Default = false,
    Callback = function(Value)
        Settings.FarmOnlySelected = Value
    end
})

MainTab:AddSection({
    Name = "Collecting"
})

MainTab:AddToggle({
    Name = "Auto Collect Chests",
    Default = false,
    Callback = function(Value)
        Settings.AutoCollectChests = Value
        if Value then
            StartChestCollector()
        end
    end
})

MainTab:AddToggle({
    Name = "Auto Collect Fruits",
    Default = false,
    Callback = function(Value)
        Settings.AutoCollectFruits = Value
        if Value then
            StartFruitCollector()
        end
    end
})

MainTab:AddToggle({
    Name = "Auto Sell",
    Default = false,
    Callback = function(Value)
        Settings.AutoSell = Value
        if Value then
            StartAutoSell()
        end
    end
})

-- Levi Tab Content
LeviTab:AddSection({
    Name = "Levi Skills"
})

LeviTab:AddToggle({
    Name = "Auto Levi Skills",
    Default = false,
    Callback = function(Value)
        Settings.AutoLevi = Value
        if Value then
            StartLeviSkills()
        else
            StopLeviSkills()
        end
    end
})

LeviTab:AddSlider({
    Name = "Skill Delay",
    Min = 0.5,
    Max = 5,
    Default = 1,
    Color = Colors.Accent,
    Increment = 0.1,
    ValueName = "seconds",
    Callback = function(Value)
        Settings.LeviSkillDelay = Value
    end
})

LeviTab:AddToggle({
    Name = "Use Levi Dash (Z)",
    Default = true,
    Callback = function(Value)
        Settings.UseLeviDash = Value
    end
})

LeviTab:AddToggle({
    Name = "Use Levi Spin (X)",
    Default = true,
    Callback = function(Value)
        Settings.UseLeviSpin = Value
    end
})

LeviTab:AddToggle({
    Name = "Use Levi Flight (C)",
    Default = true,
    Callback = function(Value)
        Settings.UseLeviFlight = Value
    end
})

LeviTab:AddButton({
    Name = "Levi Dash (Z)",
    Callback = function()
        UseLeviSkill("Levi Dash")
    end
})

LeviTab:AddButton({
    Name = "Levi Spin (X)",
    Callback = function()
        UseLeviSkill("Levi Spin")
    end
})

LeviTab:AddButton({
    Name = "Levi Flight (C)",
    Callback = function()
        UseLeviSkill("Levi Flight")
    end
})

LeviTab:AddButton({
    Name = "Levi Vortex (V)",
    Callback = function()
        UseLeviSkill("Levi Vortex")
    end
})

LeviTab:AddButton({
    Name = "Levi Tsunami (F)",
    Callback = function()
        UseLeviSkill("Levi Tsunami")
    end
})

LeviTab:AddSection({
    Name = "Skill Combo"
})

LeviTab:AddDropdown({
    Name = "Combo Pattern",
    Default = "Dash -> Spin -> Flight",
    Options = {"Dash -> Spin -> Flight", "Spin -> Dash -> Flight", "Flight -> Spin -> Dash", "Random Pattern"},
    Callback = function(Value)
        Settings.ComboPattern = Value
    end
})

LeviTab:AddToggle({
    Name = "Use Skill Combo",
    Default = false,
    Callback = function(Value)
        Settings.UseSkillCombo = Value
    end
})

-- Boat Tab Content
BoatTab:AddSection({
    Name = "Boat Control"
})

BoatTab:AddToggle({
    Name = "Auto Boat Navigation",
    Default = false,
    Callback = function(Value)
        Settings.AutoBoat = Value
        if Value then
            StartBoatNavigation()
        else
            StopBoatNavigation()
        end
    end
})

BoatTab:AddToggle({
    Name = "Auto Spawn Boat",
    Default = false,
    Callback = function(Value)
        Settings.AutoSpawnBoat = Value
    end
})

BoatTab:AddSlider({
    Name = "Boat Speed",
    Min = 50,
    Max = 200,
    Default = 100,
    Color = Colors.Accent,
    Increment = 5,
    ValueName = "speed",
    Callback = function(Value)
        Settings.BoatSpeed = Value
    end
})

BoatTab:AddDropdown({
    Name = "Destination",
    Default = "Tiki Island",
    Options = {"Tiki Island", "Hydra Island", "Shark Island", "Frozen Island", "Desert Island"},
    Callback = function(Value)
        Settings.BoatDestination = Value
    end
})

BoatTab:AddToggle({
    Name = "Auto Dock at Island",
    Default = true,
    Callback = function(Value)
        Settings.AutoDock = Value
    end
})

BoatTab:AddToggle({
    Name = "Follow Sea Beasts",
    Default = false,
    Callback = function(Value)
        Settings.FollowSeaBeasts = Value
    end
})

BoatTab:AddSection({
    Name = "Quick Actions"
})

BoatTab:AddButton({
    Name = "Spawn Boat",
    Callback = function()
        SpawnBoat()
    end
})

BoatTab:AddButton({
    Name = "Drive to Tiki Island",
    Callback = function()
        DriveBoatToIsland("Tiki Island")
    end
})

BoatTab:AddButton({
    Name = "Drive to Hydra Island",
    Callback = function()
        DriveBoatToIsland("Hydra Island")
    end
})

BoatTab:AddButton({
    Name = "Drive to Shark Island",
    Callback = function()
        DriveBoatToIsland("Shark Island")
    end
})

BoatTab:AddButton({
    Name = "Enter Nearest Boat",
    Callback = function()
        local boat = GetNearestBoat()
        if boat and boat:FindFirstChild("VehicleSeat") then
            HumanoidRootPart.CFrame = CFrame.new(boat.VehicleSeat.Position)
            task.wait(0.5)
            fireproximityprompt(boat.VehicleSeat.Enter)
            Notify("Boat", "Entered boat!", 3)
        else
            Notify("Boat", "No boat found nearby!", 3)
        end
    end
})

-- Island Tab Content
IslandTab:AddSection({
    Name = "Island Automation"
})

IslandTab:AddToggle({
    Name = "Auto Tiki Island",
    Default = false,
    Callback = function(Value)
        Settings.AutoTikiIsland = Value
        if Value then
            StartTikiIsland()
        else
            StopTikiIsland()
        end
    end
})

IslandTab:AddToggle({
    Name = "Auto Hydra Island",
    Default = false,
    Callback = function(Value)
        Settings.AutoHydraIsland = Value
        if Value then
            StartHydraIsland()
        else
            StopHydraIsland()
        end
    end
})

IslandTab:AddDropdown({
    Name = "Island Farm Mode",
    Default = "Mobs",
    Options = {"Mobs", "Boss", "Chests", "Resources", "All"},
    Callback = function(Value)
        Settings.IslandFarmMode = Value
    end
})

IslandTab:AddToggle({
    Name = "Collect Tiki Totems",
    Default = true,
    Callback = function(Value)
        Settings.CollectTikiTotems = Value
    end
})

IslandTab:AddToggle({
    Name = "Collect Hydra Scales",
    Default = true,
    Callback = function(Value)
        Settings.CollectHydraScales = Value
    end
})

IslandTab:AddSection({
    Name = "Island Teleports"
})

for islandName, islandData in pairs(IslandLocations) do
    IslandTab:AddButton({
        Name = "Teleport to " .. islandName,
        Callback = function()
            HumanoidRootPart.CFrame = CFrame.new(islandData.Position)
            Notify("Island", "Teleported to " .. islandName, 3)
        end
    })
end

IslandTab:AddSection({
    Name = "Island Information"
})

IslandTab:AddLabel("Tiki Island: Level 1000+ recommended")
IslandTab:AddLabel("Hydra Island: Level 1200+ recommended")
IslandTab:AddLabel("Shark Island: Level 800+ recommended")
IslandTab:AddLabel("Use boat to travel to islands")

-- Auto Buy Tab Content
AutoBuyTab:AddSection({
    Name = "Auto Purchase System"
})

AutoBuyTab:AddToggle({
    Name = "Auto Buy Levi Chip",
    Default = false,
    Callback = function(Value)
        Settings.AutoBuyLeviChip = Value
        if Value then
            StartAutoBuyLeviChip()
        end
    end
})

AutoBuyTab:AddToggle({
    Name = "Auto Buy Swords",
    Default = false,
    Callback = function(Value)
        Settings.AutoBuySwords = Value
        if Value then
            StartAutoBuySwords()
        end
    end
})

AutoBuyTab:AddToggle({
    Name = "Auto Buy Fruits",
    Default = false,
    Callback = function(Value)
        Settings.AutoBuyFruits = Value
        if Value then
            StartAutoBuyFruits()
        end
    end
})

AutoBuyTab:AddToggle({
    Name = "Auto Buy Accessories",
    Default = false,
    Callback = function(Value)
        Settings.AutoBuyAccessories = Value
    end
})

AutoBuyTab:AddToggle({
    Name = "Buy Only Best Items",
    Default = true,
    Callback = function(Value)
        Settings.BuyOnlyBest = Value
    end
})

AutoBuyTab:AddSection({
    Name = "Quick Buy"
})

for itemName, itemData in pairs(BuyableItems) do
    AutoBuyTab:AddButton({
        Name = "Buy " .. itemName .. " - $" .. itemData.Price,
        Callback = function()
            AutoBuyItem(itemName)
        end
    })
end

AutoBuyTab:AddSection({
    Name = "Purchase Settings"
})

AutoBuyTab:AddSlider({
    Name = "Minimum Beli for Purchase",
    Min = 1000,
    Max = 10000000,
    Default = 1000000,
    Color = Colors.Accent,
    Increment = 10000,
    ValueName = "Beli",
    Callback = function(Value)
        Settings.MinBeliForPurchase = Value
    end
})

-- Raid Tab Content
RaidTab:AddSection({
    Name = "Leviathan Raid"
})

RaidTab:AddToggle({
    Name = "Auto Leviathan Raid",
    Default = false,
    Callback = function(Value)
        Settings.AutoLeviRaid = Value
        if Value then
            StartLeviathanRaid()
        else
            StopLeviathanRaid()
        end
    end
})

RaidTab:AddToggle({
    Name = "Use Spawn Boat for Raid",
    Default = true,
    Callback = function(Value)
        Settings.UseSpawnBoatRaid = Value
    end
})

RaidTab:AddToggle({
    Name = "Auto Collect Levi Hearts",
    Default = false,
    Callback = function(Value)
        Settings.AutoCollectLeviHearts = Value
    end
})

RaidTab:AddSlider({
    Name = "Raid Stage",
    Min = 1,
    Max = 5,
    Default = 1,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "stage",
    Callback = function(Value)
        Settings.LeviRaidStage = Value
    end
})

RaidTab:AddSection({
    Name = "Raid Actions"
})

RaidTab:AddButton({
    Name = "Start Leviathan Raid",
    Callback = function()
        StartLeviathanRaid()
    end
})

RaidTab:AddButton({
    Name = "Teleport to Raid Island",
    Callback = function()
        HumanoidRootPart.CFrame = CFrame.new(-4600, 100, -250)
        Notify("Raid", "Teleported to Leviathan Island", 3)
    end
})

RaidTab:AddButton({
    Name = "Collect All Hearts",
    Callback = function()
        CollectLeviHearts()
    end
})

-- Combat Tab Content
CombatTab:AddSection({
    Name = "Combat Settings"
})

CombatTab:AddToggle({
    Name = "Auto Dodge",
    Default = true,
    Callback = function(Value)
        Settings.AutoDodge = Value
    end
})

CombatTab:AddToggle({
    Name = "Auto Block",
    Default = true,
    Callback = function(Value)
        Settings.AutoBlock = Value
    end
})

CombatTab:AddToggle({
    Name = "Use M1 Combo",
    Default = true,
    Callback = function(Value)
        Settings
})

CombatTab:AddToggle({
    Name = "Use Skills Combo",
    Default = true,
    Callback = function(Value)
        Settings.UseSkillsCombo = Value
    end
})

CombatTab:AddDropdown({
    Name = "Combat Mode",
    Default = "Balanced",
    Options = {"Aggressive", "Balanced", "Defensive", "Ranged", "Melee"},
    Callback = function(Value)
        Settings.CombatMode = Value
    end
})

CombatTab:AddSlider({
    Name = "Attack Distance",
    Min = 5,
    Max = 50,
    Default = 10,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "studs",
    Callback = function(Value)
        Settings.AttackDistance = Value
    end
})

CombatTab:AddSlider({
    Name = "Retreat Health %",
    Min = 10,
    Max = 90,
    Default = 30,
    Color = Colors.Accent,
    Increment = 5,
    ValueName = "%",
    Callback = function(Value)
        Settings.RetreatHealth = Value
    end
})

CombatTab:AddSection({
    Name = "Weapon Management"
})

CombatTab:AddButton({
    Name = "Equip Best Sword",
    Callback = function()
        EquipBestWeapon("Sword")
    end
})

CombatTab:AddButton({
    Name = "Equip Best Fruit",
    Callback = function()
        EquipBestWeapon("Fruit")
    end
})

CombatTab:AddButton({
    Name = "Equip Best Gun",
    Callback = function()
        EquipBestWeapon("Gun")
    end
})

CombatTab:AddToggle({
    Name = "Auto Switch Weapons",
    Default = false,
    Callback = function(Value)
        Settings.AutoSwitchWeapons = Value
    end
})

CombatTab:AddSection({
    Name = "Combo Editor"
})

CombatTab:AddTextbox({
    Name = "Custom Combo (Keys)",
    Default = "Z,X,C,V",
    TextDisappear = false,
    Callback = function(Value)
        Settings.CustomCombo = Value
    end
})

CombatTab:AddButton({
    Name = "Save Combo",
    Callback = function()
        SaveCombo(Settings.CustomCombo)
    end
})

CombatTab:AddButton({
    Name = "Test Combo",
    Callback = function()
        ExecuteCombo(Settings.CustomCombo)
    end
})

-- Player Tab Content
PlayerTab:AddSection({
    Name = "Character Stats"
})

PlayerTab:AddSlider({
    Name = "WalkSpeed",
    Min = 16,
    Max = 500,
    Default = 16,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "speed",
    Callback = function(Value)
        Settings.WalkSpeed = Value
        Humanoid.WalkSpeed = Value
    end
})

PlayerTab:AddSlider({
    Name = "JumpPower",
    Min = 50,
    Max = 500,
    Default = 50,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "power",
    Callback = function(Value)
        Settings.JumpPower = Value
        Humanoid.JumpPower = Value
    end
})

PlayerTab:AddSlider({
    Name = "Hip Height",
    Min = 0,
    Max = 100,
    Default = 0,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "height",
    Callback = function(Value)
        Humanoid.HipHeight = Value
    end
})

PlayerTab:AddSection({
    Name = "Abilities"
})

PlayerTab:AddToggle({
    Name = "No Clip",
    Default = false,
    Callback = function(Value)
        Settings.NoClip = Value
        if Value then
            StartNoClip()
        end
    end
})

PlayerTab:AddToggle({
    Name = "Infinite Energy",
    Default = false,
    Callback = function(Value)
        Settings.InfiniteEnergy = Value
        if Value then
            EnableInfiniteEnergy()
        end
    end
})

PlayerTab:AddToggle({
    Name = "God Mode",
    Default = false,
    Callback = function(Value)
        Settings.GodMode = Value
        if Value then
            EnableGodMode()
        end
    end
})

PlayerTab:AddToggle({
    Name = "Fly",
    Default = false,
    Callback = function(Value)
        Settings.Fly = Value
        if Value then
            EnableFly()
        else
            DisableFly()
        end
    end
})

PlayerTab:AddSection({
    Name = "Visual"
})

PlayerTab:AddToggle({
    Name = "Hide Username",
    Default = false,
    Callback = function(Value)
        Settings.HideUsername = Value
        if Value then
            HideUsername()
        else
            ShowUsername()
        end
    end
})

PlayerTab:AddToggle({
    Name = "Hide Name Tag",
    Default = false,
    Callback = function(Value)
        Settings.HideNameTag = Value
        if Value then
            HideNameTag()
        else
            ShowNameTag()
        end
    end
})

PlayerTab:AddButton({
    Name = "Reset Character",
    Callback = function()
        Player.Character:BreakJoints()
    end
})

PlayerTab:AddButton({
    Name = "Heal Character",
    Callback = function()
        Humanoid.Health = Humanoid.MaxHealth
    end
})

-- Server Tab Content
ServerTab:AddSection({
    Name = "Server Join"
})

ServerTab:AddTextbox({
    Name = "Server JobId",
    Default = "",
    TextDisappear = true,
    Callback = function(Value)
        Settings.ServerId = Value
    end
})

ServerTab:AddButton({
    Name = "Join by JobId",
    Callback = function()
        if Settings.ServerId and Settings.ServerId ~= "" then
            TeleportService:TeleportToPlaceInstance(game.PlaceId, Settings.ServerId)
        else
            Notify("Error", "Please enter a valid JobId!", 3)
        end
    end
})

ServerTab:AddSection({
    Name = "Server Management"
})

ServerTab:AddToggle({
    Name = "Auto Rejoin on Kick",
    Default = false,
    Callback = function(Value)
        Settings.AutoRejoin = Value
        if Value then
            StartAutoRejoin()
        end
    end
})

ServerTab:AddSlider({
    Name = "Rejoin Delay",
    Min = 1,
    Max = 30,
    Default = 5,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "seconds",
    Callback = function(Value)
        Settings.AutoJoinDelay = Value
    end
})

ServerTab:AddToggle({
    Name = "Server Hop on Low Players",
    Default = false,
    Callback = function(Value)
        Settings.ServerHopOnLowPlayers = Value
    end
})

ServerTab:AddSlider({
    Name = "Minimum Players",
    Min = 1,
    Max = 20,
    Default = 5,
    Color = Colors.Accent,
    Increment = 1,
    ValueName = "players",
    Callback = function(Value)
        Settings.MinimumPlayers = Value
    end
})

ServerTab:AddSection({
    Name = "Quick Actions"
})

ServerTab:AddButton({
    Name = "Rejoin Current Server",
    Callback = function()
        TeleportService:Teleport(game.PlaceId)
    end
})

ServerTab:AddButton({
    Name = "Server Hop",
    Callback = function()
        ServerHop()
    end
})

ServerTab:AddButton({
    Name = "Copy Current JobId",
    Callback = function()
        local JobId = game.JobId
        setclipboard(JobId)
        Notify("Server", "JobId copied to clipboard: " .. JobId, 3)
    end
})

ServerTab:AddSection({
    Name = "Player List"
})

ServerTab:AddLabel("Total Players: " .. #Players:GetPlayers())

for _, plr in pairs(Players:GetPlayers()) do
    if plr ~= Player then
        ServerTab:AddButton({
            Name = plr.Name,
            Callback = function()
                TeleportToPlayer(plr)
            end
        })
    end
end

-- Settings Tab Content
SettingsTab:AddSection({
    Name = "UI Settings"
})

SettingsTab:AddDropdown({
    Name = "UI Theme",
    Default = "Dark",
    Options = {"Dark", "Light", "Blue", "Red", "Green", "Purple"},
    Callback = function(Value)
        Settings.UITheme = Value
        ChangeUITheme(Value)
    end
})

SettingsTab:AddSlider({
    Name = "UI Size",
    Min = 0.5,
    Max = 1.5,
    Default = 1,
    Color = Colors.Accent,
    Increment = 0.1,
    ValueName = "scale",
    Callback = function(Value)
        Settings.UISize = Value
        ResizeUI(Value)
    end
})

SettingsTab:AddToggle({
    Name = "Save Settings",
    Default = true,
    Callback = function(Value)
        Settings.SaveSettings = Value
    end
})

SettingsTab:AddToggle({
    Name = "Watermark",
    Default = true,
    Callback = function(Value)
        Settings.Watermark = Value
        ToggleWatermark(Value)
    end
})

SettingsTab:AddToggle({
    Name = "Keybinds",
    Default = true,
    Callback = function(Value)
        Settings.ShowKeybinds = Value
        ToggleKeybinds(Value)
    end
})

SettingsTab:AddSection({
    Name = "Performance"
})

SettingsTab:AddToggle({
    Name = "Low Graphics",
    Default = false,
    Callback = function(Value)
        Settings.LowGraphics = Value
        if Value then
            EnableLowGraphics()
        else
            DisableLowGraphics()
        end
    end
})

SettingsTab:AddToggle({
    Name = "Remove Effects",
    Default = false,
    Callback = function(Value)
        Settings.RemoveEffects = Value
        if Value then
            RemoveVisualEffects()
        end
    end
})

SettingsTab:AddSlider({
    Name = "Render Distance",
    Min = 100,
    Max = 10000,
    Default = 1000,
    Color = Colors.Accent,
    Increment = 100,
    ValueName = "studs",
    Callback = function(Value)
        Settings.RenderDistance = Value
        SetRenderDistance(Value)
    end
})

SettingsTab:AddSection({
    Name = "ESP Settings"
})

SettingsTab:AddToggle({
    Name = "Enable ESP",
    Default = false,
    Callback = function(Value)
        Settings.ESPEnabled = Value
        if Value then
            EnableESP()
        else
            DisableESP()
        end
    end
})

SettingsTab:AddToggle({
    Name = "Show Mobs ESP",
    Default = true,
    Callback = function(Value)
        Settings.ESPMobs = Value
    end
})

SettingsTab:AddToggle({
    Name = "Show Chests ESP",
    Default = true,
    Callback = function(Value)
        Settings.ESPChests = Value
    end
})

SettingsTab:AddToggle({
    Name = "Show Fruits ESP",
    Default = true,
    Callback = function(Value)
        Settings.ESPFruits = Value
    end
})

SettingsTab:AddToggle({
    Name = "Show Players ESP",
    Default = false,
    Callback = function(Value)
        Settings.ESPPlayers = Value
    end
})

SettingsTab:AddColorpicker({
    Name = "ESP Color",
    Default = Color3.fromRGB(0, 255, 0),
    Callback = function(Value)
        Settings.ESPColor = Value
    end
})

SettingsTab:AddSection({
    Name = "Script Control"
})

SettingsTab:AddButton({
    Name = "Save All Settings",
    Callback = function()
        SaveSettings()
        Notify("Settings", "All settings saved!", 3)
    end
})

SettingsTab:AddButton({
    Name = "Load Settings",
    Callback = function()
        LoadSettings()
        Notify("Settings", "Settings loaded!", 3)
    end
})

SettingsTab:AddButton({
    Name = "Reset Settings",
    Callback = function()
        ResetSettings()
        Notify("Settings", "Settings reset to default!", 3)
    end
})

SettingsTab:AddButton({
    Name = "Toggle UI",
    Callback = function()
        OrionLib:ToggleUI()
    end
})

SettingsTab:AddButton({
    Name = "Destroy UI",
    Callback = function()
        OrionLib:Destroy()
        Notify("UI", "UI destroyed! Re-execute script to show again.", 5)
    end
})

SettingsTab:AddSection({
    Name = "Script Info"
})

SettingsTab:AddLabel("Astra Hub")
SettingsTab:AddLabel("Kaitun Levi")
SettingsTab:AddLabel("by White")
SettingsTab:AddLabel("Last Updated: " .. os.date("%Y-%m-%d"))
SettingsTab:AddLabel("Player: " .. Player.Name)
SettingsTab:AddLabel("Level: " .. GetPlayerLevel())
SettingsTab:AddLabel("Beli: " .. GetPlayerBeli())

-- Main Functions
function StartAutoFarm()
    if FarmLoop then
        FarmLoop:Disconnect()
        FarmLoop = nil
    end
    
    FarmLoop = RunService.Heartbeat:Connect(function()
        if Settings.AutoFarm and Character and Humanoid.Health > 0 then
            local target = GetBestFarmTarget()
            if target then
                FarmTarget(target)
            end
        end
    end)
end

function StopAutoFarm()
    if FarmLoop then
        FarmLoop:Disconnect()
        FarmLoop = nil
    end
end

function GetBestFarmTarget()
    local mobs = {}
    local playerPos = HumanoidRootPart.Position
    
    -- Collect all valid mobs
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
            local distance = (playerPos - mob.HumanoidRootPart.Position).Magnitude
            if distance <= Settings.FarmRange then
                if Settings.FarmOnlySelected and Settings.SelectedMob ~= "" then
                    if mob.Name:find(Settings.SelectedMob) then
                        table.insert(mobs, mob)
                    end
                else
                    table.insert(mobs, mob)
                end
            end
        end
    end
    
    if #mobs == 0 then
        return nil
    end
    
    -- Sort mobs based on priority
    if Settings.MobPriority == "Nearest" then
        table.sort(mobs, function(a, b)
            local distA = (playerPos - a.HumanoidRootPart.Position).Magnitude
            local distB = (playerPos - b.HumanoidRootPart.Position).Magnitude
            return distA < distB
        end)
    elseif Settings.MobPriority == "Highest Level" then
        table.sort(mobs, function(a, b)
            local levelA = a:GetAttribute("Level") or 0
            local levelB = b:GetAttribute("Level") or 0
            return levelA > levelB
        end)
    elseif Settings.MobPriority == "Lowest Level" then
        table.sort(mobs, function(a, b)
            local levelA = a:GetAttribute("Level") or 0
            local levelB = b:GetAttribute("Level") or 0
            return levelA < levelB
        end)
    elseif Settings.MobPriority == "Highest Health" then
        table.sort(mobs, function(a, b)
            return a.Humanoid.Health > b.Humanoid.Health
        end)
    elseif Settings.MobPriority == "Lowest Health" then
        table.sort(mobs, function(a, b)
            return a.Humanoid.Health < b.Humanoid.Health
        end)
    elseif Settings.MobPriority == "Boss Priority" then
        table.sort(mobs, function(a, b)
            local isBossA = a.Name:find("Boss") or a.Name:find("King") or a.Name:find("Queen")
            local isBossB = b.Name:find("Boss") or b.Name:find("King") or b.Name:find("Queen")
            if isBossA and not isBossB then
                return true
            elseif not isBossA and isBossB then
                return false
            end
            local levelA = a:GetAttribute("Level") or 0
            local levelB = b:GetAttribute("Level") or 0
            return levelA > levelB
        end)
    end
    
    return mobs[1]
end

function FarmTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local targetPos = target.HumanoidRootPart.Position
    local distance = (HumanoidRootPart.Position - targetPos).Magnitude
    
    -- Move to target
    if distance > 10 then
        HumanoidRootPart.CFrame = CFrame.new(targetPos + (HumanoidRootPart.Position - targetPos).Unit * 10)
    end
    
    -- Face target
    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position, targetPos)
    
    -- Attack if in range
    if distance <= 20 and Settings.AutoAttack then
        AttackTarget(target)
    end
    
    -- Use Levi skills if enabled
    if Settings.AutoLevi and distance <= 50 then
        UseLeviCombo()
    end
end

function AttackTarget(target)
    if not target or target.Humanoid.Health <= 0 then
        return
    end
    
    -- M1 Attack
    if Settings.UseM1Combo then
        VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
    end
    
    -- Skill attacks
    if Settings.UseSkillsCombo then
        UseSkillCombo()
    end
end

function UseLeviSkill(skillName)
    if not LeviSkills[skillName] then
        return
    end
    
    local skill = LeviSkills[skillName]
    VirtualInputManager:SendKeyEvent(true, skill.Key, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, skill.Key, false, game)
    
    Notify("Levi Skill", "Used " .. skillName, 2)
end

function StartLeviSkills()
    if LeviLoop then
        LeviLoop:Disconnect()
        LeviLoop = nil
    end
    
    LeviLoop = RunService.Heartbeat:Connect(function()
        if Settings.AutoLevi then
            UseLeviCombo()
            task.wait(Settings.LeviSkillDelay)
        end
    end)
end

function StopLeviSkills()
    if LeviLoop then
        LeviLoop:Disconnect()
        LeviLoop = nil
    end
end

function UseLeviCombo()
    if Settings.UseLeviDash then
        UseLeviSkill("Levi Dash")
        task.wait(0.5)
    end
    
    if Settings.UseLeviSpin then
        UseLeviSkill("Levi Spin")
        task.wait(0.5)
    end
    
    if Settings.UseLeviFlight then
        UseLeviSkill("Levi Flight")
        task.wait(0.5)
    end
end

function StartBoatNavigation()
    if BoatLoop then
        BoatLoop:Disconnect()
        BoatLoop = nil
    end
    
    BoatLoop = RunService.Heartbeat:Connect(function()
        if Settings.AutoBoat then
            NavigateBoat()
        end
    end)
end

function StopBoatNavigation()
    if BoatLoop then
        BoatLoop:Disconnect()
        BoatLoop = nil
    end
end

function NavigateBoat()
    if not CurrentBoat or not CurrentBoat:FindFirstChild("Main") then
        -- Try to find boat
        CurrentBoat = GetNearestBoat()
        if not CurrentBoat then
            if Settings.AutoSpawnBoat then
                SpawnBoat()
            end
            return
        end
    end
    
    local islandData = IslandLocations[Settings.BoatDestination]
    if not islandData then
        return
    end
    
    local boatPos = CurrentBoat.Main.Position
    local targetPos = islandData.Position
    local distance = (boatPos - targetPos).Magnitude
    
    -- If close to island, dock
    if distance < 200 and Settings.AutoDock then
        DockBoat(islandData)
        return
    end
    
    -- Navigate to island
    local direction = (targetPos - boatPos).Unit
    CurrentBoat.Main.Velocity = direction * Settings.BoatSpeed
    
    -- Avoid obstacles
    AvoidObstacles()
end

function DockBoat(islandData)
    local dockPos = islandData.DockPosition or islandData.Position
    local boatPos = CurrentBoat.Main.Position
    local direction = (dockPos - boatPos).Unit
    
    CurrentBoat.Main.Velocity = direction * (Settings.BoatSpeed / 2)
    
    -- If close enough, stop
    if (boatPos - dockPos).Magnitude < 50 then
        CurrentBoat.Main.Velocity = Vector3.new(0, 0, 0)
        Settings.AutoBoat = false
        
        -- Exit boat
        if CurrentBoat:FindFirstChild("VehicleSeat") then
            fireproximityprompt(CurrentBoat.VehicleSeat.Leave)
        end
        
        Notify("Boat", "Docked at " .. Settings.BoatDestination, 3)
    end
end

function AvoidObstacles()
    if not CurrentBoat then
        return
    end
    
    local boatPos = CurrentBoat.Main.Position
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {CurrentBoat, Character}
    
    -- Check for obstacles in front
    local raycastResult = Workspace:Raycast(
        boatPos,
        CurrentBoat.Main.CFrame.LookVector * 100,
        raycastParams
    )
    
    if raycastResult then
        -- Turn to avoid obstacle
        local avoidDirection = (CurrentBoat.Main.CFrame.LookVector:Cross(Vector3.new(0, 1, 0))).Unit
        CurrentBoat.Main.Velocity = avoidDirection * Settings.BoatSpeed
        task.wait(1)
    end
end

function StartTikiIsland()
    TikiIslandActive = true
    
    coroutine.wrap(function()
        while Settings.AutoTikiIsland do
            -- Check if already on island
            local onIsland, islandName = IsPlayerInIsland()
            if not onIsland then
                -- Use boat to get to island
                DriveBoatToIsland("Tiki Island")
                
                -- Wait until arrived
                repeat
                    task.wait(2)
                    onIsland, islandName = IsPlayerInIsland()
                until onIsland or not Settings.AutoTikiIsland
                
                if not Settings.AutoTikiIsland then
                    break
                end
            end
            
            -- Execute island farming based on mode
            if Settings.IslandFarmMode == "Mobs" then
                FarmTikiMobs()
            elseif Settings.IslandFarmMode == "Boss" then
                FarmTikiBoss()
            elseif Settings.IslandFarmMode == "Chests" then
                CollectTikiChests()
            elseif Settings.IslandFarmMode == "Resources" then
                CollectTikiResources()
            else -- "All"
                FarmTikiMobs()
                CollectTikiChests()
                CollectTikiResources()
                if Settings.CollectTikiTotems then
                    CollectTikiTotems()
                end
            end
            
            task.wait(1)
        end
        
        TikiIslandActive = false
    end)()
end

function StopTikiIsland()
    Settings.AutoTikiIsland = false
    TikiIslandActive = false
end

function FarmTikiMobs()
    local islandData = IslandLocations["Tiki Island"]
    local mobs = {}
    
    -- Find Tiki mobs
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            for _, mobName in pairs(islandData.Mobs) do
                if mob.Name:find(mobName) then
                    table.insert(mobs, mob)
                    break
                end
            end
        end
    end
    
    -- Farm mobs
    for _, mob in pairs(mobs) do
        if not Settings.AutoTikiIsland then
            break
        end
        
        FarmTarget(mob)
        task.wait(0.5)
    end
end

function CollectTikiChests()
    local islandData = IslandLocations["Tiki Island"]
    
    for _, chestType in pairs(islandData.Chests) do
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj.Name:find(chestType) then
                -- Teleport to chest
                HumanoidRootPart.CFrame = CFrame.new(obj.Position)
                task.wait(1)
                
                -- Try to open chest
                if obj:FindFirstChild("Click") then
                    fireclickdetector(obj.Click)
                end
                
                task.wait(2)
            end
        end
    end
end

function StartHydraIsland()
    HydraIslandActive = true
    
    coroutine.wrap(function()
        while Settings.AutoHydraIsland do
            -- Check if already on island
            local onIsland, islandName = IsPlayerInIsland()
            if not onIsland then
                -- Use boat to get to island
                DriveBoatToIsland("Hydra Island")
                
                -- Wait until arrived
                repeat
                    task.wait(2)
                    onIsland, islandName = IsPlayerInIsland()
                until onIsland or not Settings.AutoHydraIsland
                
                if not Settings.AutoHydraIsland then
                    break
                end
            end
            
            -- Execute island farming based on mode
            if Settings.IslandFarmMode == "Mobs" then
                FarmHydraMobs()
            elseif Settings.IslandFarmMode == "Boss" then
                FarmHydraBoss()
            elseif Settings.IslandFarmMode == "Chests" then
                CollectHydraChests()
            elseif Settings.IslandFarmMode == "Resources" then
                CollectHydraResources()
            else -- "All"
                FarmHydraMobs()
                CollectHydraChests()
                CollectHydraResources()
                if Settings.CollectHydraScales then
                    CollectHydraScales()
                end
            end
            
            task.wait(1)
        end
        
        HydraIslandActive = false
    end)()
end

function StopHydraIsland()
    Settings.AutoHydraIsland = false
    HydraIslandActive = false
end

function StartAutoBuyLeviChip()
    coroutine.wrap(function()
        while Settings.AutoBuyLeviChip do
            local playerLevel = GetPlayerLevel()
            local playerBeli = GetPlayerBeli()
            
            if playerLevel >= 1000 and playerBeli >= 1000000 then
                AutoBuyItem("Levi Chip")
                Notify("Auto Buy", "Attempting to buy Levi Chip...", 3)
            else
                if playerLevel < 1000 then
                    Notify("Auto Buy", "Level too low for Levi Chip (Need: 1000)", 3)
                end
                if playerBeli < 1000000 then
                    Notify("Auto Buy", "Beli too low for Levi Chip (Need: $1,000,000)", 3)
                end
            end
            
            task.wait(30) -- Check every 30 seconds
        end
    end)()
end

function StartAutoBuySwords()
    coroutine.wrap(function()
        while Settings.AutoBuySwords do
            local playerBeli = GetPlayerBeli()
            
            if Settings.BuyOnlyBest then
                -- Buy best sword affordable
                if playerBeli >= 1200000 then
                    AutoBuyItem("Dual Katana")
                elseif playerBeli >= 25000 then
                    AutoBuyItem("Iron Mace")
                elseif playerBeli >= 10000 then
                    AutoBuyItem("Katana")
                elseif playerBeli >= 1000 then
                    AutoBuyItem("Cutlass")
                end
            else
                -- Buy all affordable swords
                for itemName, itemData in pairs(BuyableItems) do
                    if itemData.Type == "Sword" and playerBeli >= itemData.Price then
                        AutoBuyItem(itemName)
                        task.wait(2)
                    end
                end
            end
            
            task.wait(60) -- Check every minute
        end
    end)()
end

function StartAutoBuyFruits()
    coroutine.wrap(function()
        while Settings.AutoBuyFruits do
            local playerBeli = GetPlayerBeli()
            
            for itemName, itemData in pairs(BuyableItems) do
                if itemData.Type == "Fruit" and playerBeli >= itemData.Price then
                    AutoBuyItem(itemName)
                    task.wait(2)
                end
            end
            
            task.wait(120) -- Check every 2 minutes
        end
    end)()
end

function StartLeviathanRaid()
    LeviRaidActive = true
    
    coroutine.wrap(function()
        Notify("Leviathan Raid", "Starting raid...", 3)
        
        -- Phase 1: Get to raid island
        if Settings.UseSpawnBoatRaid then
            SpawnBoat()
            task.wait(3)
            
            DriveBoatToIsland("Tiki Island") -- Temporary, would be Leviathan Island
            task.wait(10)
        else
            HumanoidRootPart.CFrame = CFrame.new(-4600, 100, -250)
        end
        
        -- Phase 2: Fight Leviathan
        while Settings.AutoLeviRaid and Settings.LeviRaidStage <= 5 do
            Notify("Leviathan Raid", "Stage " .. Settings.LeviRaidStage .. " started", 3)
            
            -- Find Leviathan
            local leviathan = FindLeviathan()
            if leviathan then
                -- Attack Leviathan
                AttackLeviathan(leviathan)
            else
                -- Move to next stage
                Settings.LeviRaidStage = Settings.LeviRaidStage + 1
                Notify("Leviathan Raid", "Moving to stage " .. Settings.LeviRaidStage, 3)
            end
            
            -- Collect hearts if enabled
            if Settings.AutoCollectLeviHearts then
                CollectLeviHearts()
            end
            
            task.wait(1)
        end
        
        if Settings.LeviRaidStage > 5 then
            Notify("Leviathan Raid", "Raid completed!", 5)
            Settings.AutoLeviRaid = false
        end
        
        LeviRaidActive = false
    end)()
end

function StopLeviathanRaid()
    Settings.AutoLeviRaid = false
    LeviRaidActive = false
end

function FindLeviathan()
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob.Name:find("Leviathan") or mob.Name:find("Sea Beast") then
            return mob
        end
    end
    return nil
end

function AttackLeviathan(leviathan)
    if not leviathan or not leviathan:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local targetPos = leviathan.HumanoidRootPart.Position
    local distance = (HumanoidRootPart.Position - targetPos).Magnitude
    
    -- Move to optimal distance
    if distance > 30 then
        HumanoidRootPart.CFrame = CFrame.new(targetPos + (HumanoidRootPart.Position - targetPos).Unit * 30)
    end
    
    -- Face Leviathan
    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position, targetPos)
    
    -- Use all attacks
    UseLeviCombo()
    
    -- M1 Attack
    VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
    
    -- Dodge if needed
    if Settings.AutoDodge and leviathan:FindFirstChild("Attack") then
        DodgeAttack(leviathan.Attack)
    end
end

function CollectLeviHearts()
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name:find("Heart") or obj.Name:find("Leviathan Heart") then
            HumanoidRootPart.CFrame = CFrame.new(obj.Position)
            task.wait(0.5)
            
            if obj:FindFirstChild("Click") then
                fireclickdetector(obj.Click)
            end
        end
    end
end

function EquipBestWeapon(weaponType)
    local backpack = Player:FindFirstChild("Backpack")
    if not backpack then
        return
    end
    
    local bestWeapon = nil
    local bestValue = 0
    
    for _, tool in pairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local isType = false
            
            if weaponType == "Sword" and (tool.Name:find("Sword") or tool.Name:find("Blade")) then
                isType = true
            elseif weaponType == "Fruit" and tool.Name:find("Fruit") then
                isType = true
            elseif weaponType == "Gun" and (tool.Name:find("Gun") or tool.Name:find("Rifle")) then
                isType = true
            end
            
            if isType then
                local damage = tool:GetAttribute("Damage") or 0
                local level = tool:GetAttribute("Level") or 0
                local value = damage + (level * 10)
                
                if value > bestValue then
                    bestValue = value
                    bestWeapon = tool
                end
            end
        end
    end
    
    if bestWeapon then
        Player.Character.Humanoid:EquipTool(bestWeapon)
        Notify("Weapon", "Equipped: " .. bestWeapon.Name, 3)
    else
        Notify("Weapon", "No " .. weaponType .. " found in backpack", 3)
    end
end

function UseSkillCombo()
    if Settings.CustomCombo and Settings.CustomCombo ~= "" then
        ExecuteCombo(Settings.CustomCombo)
    else
        -- Default combo
        VirtualInputManager:SendKeyEvent(true, "Z", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "Z", false, game)
        
        task.wait(0.3)
        
        VirtualInputManager:SendKeyEvent(true, "X", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "X", false, game)
        
        task.wait(0.3)
        
        VirtualInputManager:SendKeyEvent(true, "C", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "C", false, game)
    end
end

function ExecuteCombo(comboString)
    local keys = string.split(comboString, ",")
    
    for _, key in pairs(keys) do
        key = string.trim(key)
        if key ~= "" then
            VirtualInputManager:SendKeyEvent(true, key, false, game)
            task
            
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, key, false, game)
            task.wait(0.2)
        end
    end
end

function SaveCombo(comboString)
    Settings.CustomCombo = comboString
    Notify("Combo", "Combo saved: " .. comboString, 3)
end

function StartNoClip()
    local noClipConnection
    
    noClipConnection = RunService.Stepped:Connect(function()
        if Settings.NoClip and Character then
            for _, part in pairs(Character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        else
            if noClipConnection then
                noClipConnection:Disconnect()
            end
        end
    end)
end

function EnableInfiniteEnergy()
    local energyConnection
    
    energyConnection = RunService.Heartbeat:Connect(function()
        if Settings.InfiniteEnergy and Character then
            -- This would typically involve modifying energy values
            -- Note: Actual implementation depends on game structure
            local humanoid = Character:FindFirstChild("Humanoid")
            if humanoid then
                -- Try to find energy related attributes
                for _, attr in pairs(humanoid:GetAttributes()) do
                    if string.find(attr, "Energy") or string.find(attr, "Stamina") then
                        humanoid:SetAttribute(attr, 100)
                    end
                end
            end
        else
            if energyConnection then
                energyConnection:Disconnect()
            end
        end
    end)
end

function EnableGodMode()
    if not Character then return end
    
    local humanoid = Character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Store original health
    local originalHealth = humanoid.Health
    
    -- Make character invulnerable
    humanoid:SetAttribute("GodMode", true)
    
    -- Prevent health decrease
    local healthConnection
    healthConnection = humanoid.HealthChanged:Connect(function(newHealth)
        if Settings.GodMode and newHealth < humanoid.MaxHealth then
            humanoid.Health = humanoid.MaxHealth
        end
    end)
    
    -- Make parts invulnerable
    for _, part in pairs(Character:GetDescendants()) do
        if part:IsA("BasePart") then
            part:SetAttribute("GodMode", true)
        end
    end
    
    Notify("God Mode", "God Mode enabled!", 3)
end

function EnableFly()
    local flying = false
    local flySpeed = 50
    local bodyGyro = nil
    local bodyVelocity = nil
    
    -- Create flying controls
    local function startFlying()
        if flying or not Character then return end
        
        flying = true
        Humanoid.PlatformStand = true
        
        -- Create BodyGyro for rotation
        bodyGyro = Instance.new("BodyGyro")
        bodyGyro.P = 10000
        bodyGyro.MaxTorque = Vector3.new(10000, 10000, 10000)
        bodyGyro.CFrame = HumanoidRootPart.CFrame
        bodyGyro.Parent = HumanoidRootPart
        
        -- Create BodyVelocity for movement
        bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(10000, 10000, 10000)
        bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        bodyVelocity.Parent = HumanoidRootPart
        
        -- Movement controls
        local flyConnection
        flyConnection = RunService.Heartbeat:Connect(function()
            if not flying or not Character then
                flyConnection:Disconnect()
                return
            end
            
            local velocity = Vector3.new(0, 0, 0)
            
            -- Forward/Backward
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                velocity = velocity + (HumanoidRootPart.CFrame.LookVector * flySpeed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                velocity = velocity - (HumanoidRootPart.CFrame.LookVector * flySpeed)
            end
            
            -- Left/Right
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                velocity = velocity + (HumanoidRootPart.CFrame.RightVector * flySpeed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                velocity = velocity - (HumanoidRootPart.CFrame.RightVector * flySpeed)
            end
            
            -- Up/Down
            if UserInputService:IsKeyDown(Enum.KeyCode.E) then
                velocity = velocity + Vector3.new(0, flySpeed, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
                velocity = velocity - Vector3.new(0, flySpeed, 0)
            end
            
            bodyVelocity.Velocity = velocity
            
            -- Update gyro
            if bodyGyro then
                bodyGyro.CFrame = CFrame.new(HumanoidRootPart.Position, HumanoidRootPart.Position + Mouse.Hit.lookVector)
            end
        end)
        
        Notify("Fly", "Fly mode enabled! (WASD to move, E/Q to go up/down)", 5)
    end
    
    local function stopFlying()
        if not flying then return end
        
        flying = false
        Humanoid.PlatformStand = false
        
        if bodyGyro then
            bodyGyro:Destroy()
            bodyGyro = nil
        end
        
        if bodyVelocity then
            bodyVelocity:Destroy()
            bodyVelocity = nil
        end
        
        Notify("Fly", "Fly mode disabled", 3)
    end
    
    -- Toggle fly
    if Settings.Fly then
        startFlying()
    else
        stopFlying()
    end
end

function DisableFly()
    Settings.Fly = false
    EnableFly() -- This will trigger stopFlying
end

function HideUsername()
    if Character then
        local humanoid = Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.DisplayName = ""
        end
    end
end

function ShowUsername()
    if Character then
        local humanoid = Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.DisplayName = Player.Name
        end
    end
end

function HideNameTag()
    if Character then
        local head = Character:FindFirstChild("Head")
        if head then
            for _, tag in pairs(head:GetChildren()) do
                if tag:IsA("BillboardGui") then
                    tag.Enabled = false
                end
            end
        end
    end
end

function ShowNameTag()
    if Character then
        local head = Character:FindFirstChild("Head")
        if head then
            for _, tag in pairs(head:GetChildren()) do
                if tag:IsA("BillboardGui") then
                    tag.Enabled = true
                end
            end
        end
    end
end

function TeleportToPlayer(targetPlayer)
    if targetPlayer and targetPlayer.Character then
        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            HumanoidRootPart.CFrame = targetRoot.CFrame
            Notify("Teleport", "Teleported to " .. targetPlayer.Name, 3)
        end
    end
end

function StartAutoRejoin()
    coroutine.wrap(function()
        while Settings.AutoRejoin do
            task.wait(1)
            
            -- Check if player is still in game
            if not Player:IsDescendantOf(game) then
                Notify("Auto Rejoin", "Player disconnected. Rejoining in " .. Settings.AutoJoinDelay .. " seconds...", 3)
                task.wait(Settings.AutoJoinDelay)
                
                -- Try to rejoin
                local success, errorMsg = pcall(function()
                    TeleportService:Teleport(game.PlaceId)
                end)
                
                if not success then
                    Notify("Auto Rejoin", "Failed to rejoin: " .. errorMsg, 5)
                end
                
                break
            end
        end
    end)()
end

function ServerHop()
    local Http = game:GetService("HttpService")
    local TPS = game:GetService("TeleportService")
    local Api = "https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Desc&limit=100"
    
    local placeId = game.PlaceId
    local servers = {}
    
    -- Get server list
    local success, result = pcall(function()
        return Http:JSONDecode(game:HttpGet(Api:format(placeId)))
    end)
    
    if success and result.data then
        for _, server in pairs(result.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server)
            end
        end
        
        if #servers > 0 then
            -- Sort by player count
            table.sort(servers, function(a, b)
                return a.playing < b.playing
            end)
            
            -- Join server with most players
            local targetServer = servers[1]
            TPS:TeleportToPlaceInstance(placeId, targetServer.id)
            Notify("Server Hop", "Joining server with " .. targetServer.playing .. "/" .. targetServer.maxPlayers .. " players", 3)
        else
            Notify("Server Hop", "No suitable servers found", 3)
        end
    else
        Notify("Server Hop", "Failed to get server list", 3)
    end
end

function ChangeUITheme(theme)
    if theme == "Dark" then
        Colors = {
            Main = Color3.fromRGB(45, 45, 45),
            Second = Color3.fromRGB(30, 30, 30),
            Third = Color3.fromRGB(25, 25, 25),
            Accent = Color3.fromRGB(0, 170, 255),
            Text = Color3.fromRGB(255, 255, 255)
        }
    elseif theme == "Light" then
        Colors = {
            Main = Color3.fromRGB(240, 240, 240),
            Second = Color3.fromRGB(220, 220, 220),
            Third = Color3.fromRGB(200, 200, 200),
            Accent = Color3.fromRGB(0, 100, 200),
            Text = Color3.fromRGB(0, 0, 0)
        }
    elseif theme == "Blue" then
        Colors = {
            Main = Color3.fromRGB(30, 40, 60),
            Second = Color3.fromRGB(20, 30, 50),
            Third = Color3.fromRGB(10, 20, 40),
            Accent = Color3.fromRGB(0, 150, 255),
            Text = Color3.fromRGB(255, 255, 255)
        }
    elseif theme == "Red" then
        Colors = {
            Main = Color3.fromRGB(60, 30, 30),
            Second = Color3.fromRGB(50, 20, 20),
            Third = Color3.fromRGB(40, 10, 10),
            Accent = Color3.fromRGB(255, 50, 50),
            Text = Color3.fromRGB(255, 255, 255)
        }
    elseif theme == "Green" then
        Colors = {
            Main = Color3.fromRGB(30, 60, 30),
            Second = Color3.fromRGB(20, 50, 20),
            Third = Color3.fromRGB(10, 40, 10),
            Accent = Color3.fromRGB(50, 255, 50),
            Text = Color3.fromRGB(255, 255, 255)
        }
    elseif theme == "Purple" then
        Colors = {
            Main = Color3.fromRGB(50, 30, 60),
            Second = Color3.fromRGB(40, 20, 50),
            Third = Color3.fromRGB(30, 10, 40),
            Accent = Color3.fromRGB(180, 50, 255),
            Text = Color3.fromRGB(255, 255, 255)
        }
    end
    
    -- Update UI colors (this would need OrionLib modification)
    Notify("UI", "Theme changed to " .. theme, 3)
end

function ResizeUI(scale)
    -- This would resize the UI elements
    -- Implementation depends on OrionLib's capabilities
    Notify("UI", "UI size set to " .. scale .. "x", 3)
end

function ToggleWatermark(show)
    -- Toggle watermark display
    Settings.Watermark = show
end

function ToggleKeybinds(show)
    -- Toggle keybinds display
    Settings.ShowKeybinds = show
end

function EnableLowGraphics()
    -- Reduce graphics quality
    if Settings.LowGraphics then
        -- Reduce graphics level
        settings().Rendering.QualityLevel = 1
        
        -- Disable shadows
        Lighting.GlobalShadows = false
        
        -- Reduce particle count
        for _, effect in pairs(Workspace:GetDescendants()) do
            if effect:IsA("ParticleEmitter") then
                effect.Enabled = false
            end
        end
    end
end

function DisableLowGraphics()
    -- Restore graphics quality
    settings().Rendering.QualityLevel = 10
    Lighting.GlobalShadows = true
end

function RemoveVisualEffects()
    if Settings.RemoveEffects then
        -- Remove various visual effects
        for _, effect in pairs(Workspace:GetDescendants()) do
            if effect:IsA("ParticleEmitter") or 
               effect:IsA("Fire") or 
               effect:IsA("Smoke") or 
               effect:IsA("Sparkles") then
                effect:Destroy()
            end
        end
        
        -- Reduce lighting effects
        Lighting.Brightness = 2
        Lighting.OutdoorAmbient = Color3.new(0.5, 0.5, 0.5)
    end
end

function SetRenderDistance(distance)
    -- Set camera distance
    if workspace.CurrentCamera then
        workspace.CurrentCamera.CameraSubject = HumanoidRootPart
        workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        workspace.CurrentCamera.FieldOfView = 70
    end
end

function EnableESP()
    if not Settings.ESPEnabled then return end
    
    -- Clear existing ESP
    DisableESP()
    
    -- Create ESP for mobs
    if Settings.ESPMobs then
        CreateMobESP()
    end
    
    -- Create ESP for chests
    if Settings.ESPChests then
        CreateChestESP()
    end
    
    -- Create ESP for fruits
    if Settings.ESPFruits then
        CreateFruitESP()
    end
    
    -- Create ESP for players
    if Settings.ESPPlayers then
        CreatePlayerESP()
    end
end

function DisableESP()
    -- Remove all ESP objects
    for _, espObject in pairs(ESPObjects) do
        if espObject and espObject:IsA("GuiObject") then
            espObject:Destroy()
        end
    end
    ESPObjects = {}
end

function CreateMobESP()
    local espFolder = Instance.new("Folder")
    espFolder.Name = "MobESP"
    espFolder.Parent = Player:WaitForChild("PlayerGui")
    
    -- Track existing mobs
    local function addMobESP(mob)
        if not mob:FindFirstChild("HumanoidRootPart") then return end
        
        -- Create BillboardGui
        local billboard = Instance.new("BillboardGui")
        billboard.Name = mob.Name .. "_ESP"
        billboard.Adornee = mob.HumanoidRootPart
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        billboard.Parent = espFolder
        
        -- Create health bar background
        local healthBarBg = Instance.new("Frame")
        healthBarBg.Name = "HealthBarBg"
        healthBarBg.Size = UDim2.new(1, 0, 0.3, 0)
        healthBarBg.Position = UDim2.new(0, 0, 0.7, 0)
        healthBarBg.BackgroundColor3 = Color3.new(0, 0, 0)
        healthBarBg.BorderSizePixel = 1
        healthBarBg.BorderColor3 = Color3.new(1, 1, 1)
        healthBarBg.Parent = billboard
        
        -- Create health bar
        local healthBar = Instance.new("Frame")
        healthBar.Name = "HealthBar"
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = healthBarBg
        
        -- Create name label
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.Size = UDim2.new(1, 0, 0.7, 0)
        nameLabel.Position = UDim2.new(0, 0, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = mob.Name
        nameLabel.TextColor3 = Settings.ESPColor or Color3.new(0, 1, 0)
        nameLabel.TextScaled = true
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.Parent = billboard
        
        -- Store in ESPObjects
        table.insert(ESPObjects, billboard)
        
        -- Update health bar
        local humanoid = mob:FindFirstChild("Humanoid")
        if humanoid then
            local connection
            connection = humanoid.HealthChanged:Connect(function()
                if humanoid.Health > 0 then
                    local healthPercent = humanoid.Health / humanoid.MaxHealth
                    healthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
                    
                    -- Change color based on health
                    if healthPercent > 0.5 then
                        healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
                    elseif healthPercent > 0.25 then
                        healthBar.BackgroundColor3 = Color3.new(1, 1, 0)
                    else
                        healthBar.BackgroundColor3 = Color3.new(1, 0, 0)
                    end
                else
                    billboard:Destroy()
                    if connection then
                        connection:Disconnect()
                    end
                end
            end)
        end
    end
    
    -- Add ESP to existing mobs
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("Humanoid") then
            addMobESP(mob)
        end
    end
    
    -- Listen for new mobs
    local mobAddedConnection
    mobAddedConnection = Workspace.Enemies.ChildAdded:Connect(function(mob)
        task.wait(0.5) -- Wait for mob to fully load
        if mob:FindFirstChild("Humanoid") then
            addMobESP(mob)
        end
    end)
    
    table.insert(ESPObjects, mobAddedConnection)
end

function CreateChestESP()
    local espFolder = Instance.new("Folder")
    espFolder.Name = "ChestESP"
    espFolder.Parent = Player:WaitForChild("PlayerGui")
    
    local function addChestESP(chest)
        if not chest:FindFirstChild("PrimaryPart") then return end
        
        local billboard = Instance.new("BillboardGui")
        billboard.Name = chest.Name .. "_ESP"
        billboard.Adornee = chest.PrimaryPart or chest:FindFirstChildWhichIsA("BasePart")
        billboard.Size = UDim2.new(0, 150, 0, 40)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        billboard.Parent = espFolder
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = "Chest: " .. chest.Name
        label.TextColor3 = Color3.new(1, 1, 0) -- Yellow for chests
        label.TextScaled = true
        label.Font = Enum.Font.GothamBold
        label.Parent = billboard
        
        -- Add icon
        local icon = Instance.new("ImageLabel")
        icon.Size = UDim2.new(0, 30, 0, 30)
        icon.Position = UDim2.new(0.5, -15, -1.5, 0)
        icon.BackgroundTransparency = 1
        icon.Image = "rbxassetid://6023426923" -- Chest icon
        icon.Parent = billboard
        
        table.insert(ESPObjects, billboard)
    end
    
    -- Find chests
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj.Name:find("Chest") or obj.Name:find("Treasure") then
            addChestESP(obj)
        end
    end
end

function CreateFruitESP()
    local espFolder = Instance.new("Folder")
    espFolder.Name = "FruitESP"
    espFolder.Parent = Player:WaitForChild("PlayerGui")
    
    local function addFruitESP(fruit)
        if not fruit:FindFirstChild("Handle") then return end
        
        local billboard = Instance.new("BillboardGui")
        billboard.Name = fruit.Name .. "_ESP"
        billboard.Adornee = fruit.Handle
        billboard.Size = UDim2.new(0, 150, 0, 40)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        billboard.Parent = espFolder
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = "Fruit: " .. fruit.Name
        label.TextColor3 = Color3.new(1, 0.5, 0) -- Orange for fruits
        label.TextScaled = true
        label.Font = Enum.Font.GothamBold
        label.Parent = billboard
        
        table.insert(ESPObjects, billboard)
    end
    
    -- Find fruits
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj.Name:find("Fruit") and obj:IsA("Tool") then
            addFruitESP(obj)
        end
    end
end

function CreatePlayerESP()
    local espFolder = Instance.new("Folder")
    espFolder.Name = "PlayerESP"
    espFolder.Parent = Player:WaitForChild("PlayerGui")
    
    local function addPlayerESP(player)
        if player == Player then return end
        if not player.Character then return end
        
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        local billboard = Instance.new("BillboardGui")
        billboard.Name = player.Name .. "_ESP"
        billboard.Adornee = humanoidRootPart
        billboard.Size = UDim2.new(0, 200, 0, 60)
        billboard.StudsOffset = Vector3.new(0, 3.5, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        billboard.Parent = espFolder
        
        -- Name label
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
        nameLabel.Position = UDim2.new(0, 0, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = player.Name
        nameLabel.TextColor3 = Color3.new(0, 0.5, 1) -- Blue for players
        nameLabel.TextScaled = true
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.Parent = billboard
        
        -- Level label
        local levelLabel = Instance.new("TextLabel")
        levelLabel.Name = "LevelLabel"
        levelLabel.Size = UDim2.new(1, 0, 0.5, 0)
        levelLabel.Position = UDim2.new(0, 0, 0.5, 0)
        levelLabel.BackgroundTransparency = 1
        levelLabel.Text = "Level: " .. (GetPlayerLevelFromLeaderstats(player) or "?")
        levelLabel.TextColor3 = Color3.new(1, 1, 1)
        levelLabel.TextScaled = true
        levelLabel.Font = Enum.Font.Gotham
        levelLabel.Parent = billboard
        
        table.insert(ESPObjects, billboard)
        
        -- Update when character changes
        local characterAddedConnection
        characterAddedConnection = player.CharacterAdded:Connect(function()
            task.wait(1)
            billboard:Destroy()
            addPlayerESP(player)
        end)
        
        table.insert(ESPObjects, characterAddedConnection)
    end
    
    -- Add ESP for existing players
    for _, player in pairs(Players:GetPlayers()) do
        addPlayerESP(player)
    end
    
    -- Listen for new players
    local playerAddedConnection
    playerAddedConnection = Players.PlayerAdded:Connect(function(player)
        addPlayerESP(player)
    end)
    
    table.insert(ESPObjects, playerAddedConnection)
end

function GetPlayerLevelFromLeaderstats(player)
    local leaderstats = player:FindFirstChild("leaderstats")
    if leaderstats then
        local level = leaderstats:FindFirstChild("Level")
        if level then
            return level.Value
        end
    end
    return nil
end

function SaveSettings()
    -- Save settings to datastore
    local success, errorMsg = pcall(function()
        local data = HttpService:JSONEncode(Settings)
        writefile("AstraHub_Levi_Settings.json", data)
    end)
    
    if success then
        return true
    else
        Notify("Settings", "Failed to save settings: " .. errorMsg, 5)
        return false
    end
end

function LoadSettings()
    -- Load settings from file
    local success, errorMsg = pcall(function()
        if isfile("AstraHub_Levi_Settings.json") then
            local data = readfile("AstraHub_Levi_Settings.json")
            local loadedSettings = HttpService:JSONDecode(data)
            
            -- Update settings
            for key, value in pairs(loadedSettings) do
                Settings[key] = value
            end
            
            -- Update UI to reflect loaded settings
            UpdateUIFromSettings()
        end
    end)
    
    if success then
        return true
    else
        Notify("Settings", "Failed to load settings: " .. errorMsg, 5)
        return false
    end
end

function ResetSettings()
    -- Reset to default settings
    Settings = {
        AutoFarm = false,
        AutoAttack = false,
        FarmRange = 500,
        SelectedMob = "",
        MobPriority = "Nearest",
        FarmOnlySelected = false,
        AutoLevi = false,
        LeviSkillDelay = 1,
        UseLeviDash = true,
        UseLeviSpin = true,
        UseLeviFlight = true,
        AutoBoat = false,
        AutoSpawnBoat = false,
        BoatSpeed = 100,
        BoatDestination = "Tiki Island",
        FollowSeaBeasts = false,
        AutoDock = true,
        AutoBuyLeviChip = false,
        AutoBuySwords = false,
        AutoBuyFruits = false,
        AutoBuyAccessories = false,
        BuyOnlyBest = true,
        AutoLeviRaid = false,
        LeviRaidStage = 1,
        AutoCollectLeviHearts = false,
        UseSpawnBoatRaid = true,
        AutoDodge = true,
        AutoBlock = true,
        UseM1Combo = true,
        UseSkillsCombo = true,
        CombatMode = "Balanced",
        WalkSpeed = 16,
        JumpPower = 50,
        NoClip = false,
        InfiniteEnergy = false,
        GodMode = false,
        AutoRejoin = false,
        AutoJoinDelay = 5,
        ServerHopOnLowPlayers = false,
        MinimumPlayers = 5,
        UITheme = "Dark",
        UISize = 1,
        SaveSettings = true,
        AutoCollectChests = false,
        AutoCollectFruits = false,
        AntiAfk = true,
        HideUsername = false,
        AutoSell = false,
        AutoTikiIsland = false,
        AutoHydraIsland = false,
        IslandFarmMode = "Mobs",
        CollectTikiTotems = true,
        CollectHydraScales = true,
        ESPEnabled = false,
        ESPMobs = true,
        ESPChests = true,
        ESPFruits = true,
        ESPPlayers = false,
        RenderDistance = 1000,
        RemoveEffects = false,
        LowGraphics = false
    }
    
    -- Update UI
    UpdateUIFromSettings()
    Notify("Settings", "Settings reset to default", 3)
end

function UpdateUIFromSettings()
    -- This function would update all UI elements to reflect current settings
    -- Implementation would depend on OrionLib's API
    Notify("Settings", "UI updated with current settings", 3)
end

function StartChestCollector()
    coroutine.wrap(function()
        while Settings.AutoCollectChests do
            -- Find nearby chests
            local chests = {}
            for _, obj in pairs(Workspace:GetDescendants()) do
                if (obj.Name:find("Chest") or obj.Name:find("Treasure")) and 
                   obj:IsA("Model") and
                   obj:FindFirstChild("PrimaryPart") then
                    local distance = (HumanoidRootPart.Position - obj.PrimaryPart.Position).Magnitude
                    if distance < 200 then
                        table.insert(chests, obj)
                    end
                end
            end
            
            -- Sort by distance
            table.sort(chests, function(a, b)
                local distA = (HumanoidRootPart.Position - a.PrimaryPart.Position).Magnitude
                local distB = (HumanoidRootPart.Position - b.PrimaryPart.Position).Magnitude
                return distA < distB
            end)
            
            -- Collect chests
            for _, chest in pairs(chests) do
                if not Settings.AutoCollectChests then break end
                
                -- Teleport to chest
                HumanoidRootPart.CFrame = CFrame.new(chest.PrimaryPart.Position)
                task.wait(1)
                
                -- Try to open
                if chest:FindFirstChild("Click") then
                    fireclickdetector(chest.Click)
                end
                
                task.wait(2)
            end
            
            task.wait(5) -- Wait before next scan
        end
    end)()
end

function StartFruitCollector()
    coroutine.wrap(function()
        while Settings.AutoCollectFruits do
            -- Find nearby fruits
            local fruits = {}
            for _, obj in pairs(Workspace:GetDescendants()) do
                if obj.Name:find("Fruit") and obj:IsA("Tool") and obj:FindFirstChild("Handle") then
                    local distance = (HumanoidRootPart.Position - obj.Handle.Position).Magnitude
                    if distance < 200 then
                        table.insert(fruits, obj)
                    end
                end
            end
            
            -- Sort by distance
            table.sort(fruits, function(a, b)
                local distA = (HumanoidRootPart.Position - a.Handle.Position).Magnitude
                local distB = (HumanoidRootPart.Position - b.Handle.Position).Magnitude
                return distA < distB
            end)
            
            -- Collect fruits
            for _, fruit in pairs(fruits) do
                if not Settings.AutoCollectFruits then break end
                
                -- Teleport to fruit
                HumanoidRootPart.CFrame = CFrame.new(fruit.Handle.Position)
                task.wait(1)
                
                -- Pick up fruit
                firetouchinterest(HumanoidRootPart, fruit.Handle, 0)
                task.wait(0.1)
                firetouchinterest(HumanoidRootPart, fruit.Handle, 1)
                
                task.wait(2)
            end
            
            task.wait(5) -- Wait before next scan
        end
    end)()
end

function StartAutoSell()
    coroutine.wrap(function()
        while Settings.AutoSell do
            -- Find sell NPC
            local sellNPC = nil
            for _, npc in pairs(Workspace.NPCs:GetChildren()) do
                if npc.Name:find("Sell") or npc.Name:find("Merchant") then
                    sellNPC = npc
                    break
                end
            end
            
            if sellNPC then
                -- Teleport to NPC
                local originalPos = HumanoidRootPart.Position
                HumanoidRootPart.CFrame = CFrame.new(sellNPC.Position)
                task.wait(2)
                
                -- Click NPC
                if sellNPC:FindFirstChild("Click") then
                    fireclickdetector(sellNPC.Click)
                    task.wait(1)
                    
                    -- Try to sell (simulate GUI interaction)
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "E", false, game)
                    task.wait(0.1)
                    game:GetService("VirtualInputManager"):SendKeyEvent(false, "E", false, game)
                    
                    Notify("Auto Sell", "Attempted to sell items", 3)
                end
                
                -- Return to original position
                task.wait(2)
                HumanoidRootPart.CFrame = CFrame.new(originalPos)
            end
            
            task.wait(60) -- Check every minute
        end
    end)()
end

function FarmTikiBoss()
    local islandData = IslandLocations["Tiki Island"]
    local bossName = islandData.Boss
    local bossPos = islandData.BossPosition
    
    -- Teleport to boss area
    HumanoidRootPart.CFrame = CFrame.new(bossPos)
    task.wait(2)
    
    -- Find boss
    local boss = nil
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob.Name:find(bossName) and mob.Humanoid.Health > 0 then
            boss = mob
            break
        end
    end
    
    if boss then
        -- Farm boss
        while Settings.AutoTikiIsland and boss and boss.Humanoid.Health > 0 do
            FarmTarget(boss)
            task.wait(0.5)
        end
        
        if boss and boss.Humanoid.Health <= 0 then
            Notify("Tiki Island", bossName .. " defeated!", 5)
        end
    else
        Notify("Tiki Island", bossName .. " not found", 3)
    end
end

function CollectTikiResources()
    local islandData = IslandLocations["Tiki Island"]
    
    for _, resourceName in pairs(islandData.Resources) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(resourceName) and obj:IsA("BasePart") then
                
                HumanoidRootPart.CFrame = CFrame.new(obj.Position)
                task.wait(1)
                
                
                firetouchinterest(HumanoidRootPart, obj, 0)
                task.wait(0.1)
                fire

                firetouchinterest(HumanoidRootPart, obj, 1)
                
                task.wait(1)
            end
        end
    end
end

function CollectTikiTotems()
    local islandData = IslandLocations["Tiki Island"]
    
    for _, totemName in pairs(islandData.Totems) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(totemName) and (obj:IsA("BasePart") or obj:IsA("Model")) then
                -- Teleport to totem
                local part = obj:IsA("Model") and obj.PrimaryPart or obj
                if part then
                    HumanoidRootPart.CFrame = CFrame.new(part.Position)
                    task.wait(1)
                    
                    -- Collect totem
                    if obj:FindFirstChild("Click") then
                        fireclickdetector(obj.Click)
                    else
                        firetouchinterest(HumanoidRootPart, part, 0)
                        task.wait(0.1)
                        firetouchinterest(HumanoidRootPart, part, 1)
                    end
                    
                    Notify("Tiki Island", "Collected " .. totemName, 2)
                    task.wait(1)
                end
            end
        end
    end
end

function FarmHydraMobs()
    local islandData = IslandLocations["Hydra Island"]
    local mobs = {}
    
    -- Find Hydra mobs
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            for _, mobName in pairs(islandData.Mobs) do
                if mob.Name:find(mobName) then
                    table.insert(mobs, mob)
                    break
                end
            end
        end
    end
    
    -- Farm mobs
    for _, mob in pairs(mobs) do
        if not Settings.AutoHydraIsland then
            break
        end
        
        FarmTarget(mob)
        task.wait(0.5)
    end
end

function FarmHydraBoss()
    local islandData = IslandLocations["Hydra Island"]
    local bossName = islandData.Boss
    local bossPos = islandData.BossPosition
    
    -- Teleport to boss area
    HumanoidRootPart.CFrame = CFrame.new(bossPos)
    task.wait(2)
    
    -- Find boss
    local boss = nil
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob.Name:find(bossName) and mob.Humanoid.Health > 0 then
            boss = mob
            break
        end
    end
    
    if boss then
        -- Farm boss
        while Settings.AutoHydraIsland and boss and boss.Humanoid.Health > 0 do
            FarmTarget(boss)
            task.wait(0.5)
        end
        
        if boss and boss.Humanoid.Health <= 0 then
            Notify("Hydra Island", bossName .. " defeated!", 5)
        end
    else
        Notify("Hydra Island", bossName .. " not found", 3)
    end
end

function CollectHydraChests()
    local islandData = IslandLocations["Hydra Island"]
    
    for _, chestType in pairs(islandData.Chests) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(chestType) then
                -- Teleport to chest
                HumanoidRootPart.CFrame = CFrame.new(obj.Position)
                task.wait(1)
                
                -- Try to open chest
                if obj:FindFirstChild("Click") then
                    fireclickdetector(obj.Click)
                end
                
                task.wait(2)
            end
        end
    end
end

function CollectHydraResources()
    local islandData = IslandLocations["Hydra Island"]
    
    for _, resourceName in pairs(islandData.Resources) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(resourceName) and obj:IsA("BasePart") then
                -- Teleport to resource
                HumanoidRootPart.CFrame = CFrame.new(obj.Position)
                task.wait(1)
                
                -- Collect resource
                firetouchinterest(HumanoidRootPart, obj, 0)
                task.wait(0.1)
                firetouchinterest(HumanoidRootPart, obj, 1)
                
                task.wait(1)
            end
        end
    end
end

function CollectHydraScales()
    local islandData = IslandLocations["Hydra Island"]
    
    for _, scaleName in pairs(islandData.Scales) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(scaleName) and (obj:IsA("BasePart") or obj:IsA("Model")) then
                -- Teleport to scale
                local part = obj:IsA("Model") and obj.PrimaryPart or obj
                if part then
                    HumanoidRootPart.CFrame = CFrame.new(part.Position)
                    task.wait(1)
                    
                    -- Collect scale
                    if obj:FindFirstChild("Click") then
                        fireclickdetector(obj.Click)
                    else
                        firetouchinterest(HumanoidRootPart, part, 0)
                        task.wait(0.1)
                        firetouchinterest(HumanoidRootPart, part, 1)
                    end
                    
                    Notify("Hydra Island", "Collected " .. scaleName, 2)
                    task.wait(1)
                end
            end
        end
    end
end

function DodgeAttack(attack)
    if not attack then return end
    
    -- Determine dodge direction based on attack type
    local dodgeDirection = Vector3.new(0, 0, 0)
    
    if attack:IsA("BasePart") then
        local attackPos = attack.Position
        local playerPos = HumanoidRootPart.Position
        local direction = (playerPos - attackPos).Unit
        
        -- Dodge perpendicular to attack direction
        dodgeDirection = direction:Cross(Vector3.new(0, 1, 0)).Unit * 50
        
        -- Add upward component
        dodgeDirection = dodgeDirection + Vector3.new(0, 25, 0)
    end
    
    -- Apply dodge
    HumanoidRootPart.Velocity = dodgeDirection
    task.wait(0.5)
    
    -- Reset velocity
    HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
end

function FindSeaBeast()
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob.Name:find("Sea Beast") or mob.Name:find("Leviathan") then
            return mob
        end
    end
    return nil
end

function FollowSeaBeast()
    if not Settings.FollowSeaBeasts then return end
    
    local seaBeast = FindSeaBeast()
    if not seaBeast then return end
    
    if not CurrentBoat then
        CurrentBoat = GetNearestBoat()
        if not CurrentBoat then
            return
        end
    end
    
    local beastPos = seaBeast:FindFirstChild("HumanoidRootPart") and seaBeast.HumanoidRootPart.Position
    if not beastPos then return end
    
    local boatPos = CurrentBoat.Main.Position
    local distance = (boatPos - beastPos).Magnitude
    
    -- Keep a safe distance
    if distance > 100 then
        local direction = (beastPos - boatPos).Unit
        CurrentBoat.Main.Velocity = direction * Settings.BoatSpeed
    else
        -- Circle around the sea beast
        local angle = tick() * 2
        local radius = 80
        local offset = Vector3.new(
            math.cos(angle) * radius,
            0,
            math.sin(angle) * radius
        )
        
        local targetPos = beastPos + offset
        local direction = (targetPos - boatPos).Unit
        CurrentBoat.Main.Velocity = direction * (Settings.BoatSpeed * 0.5)
    end
end

function ScanForSeaBeasts()
    coroutine.wrap(function()
        while Settings.FollowSeaBeasts do
            local seaBeast = FindSeaBeast()
            if seaBeast then
                SeaBeastTarget = seaBeast
                FollowSeaBeast()
            else
                SeaBeastTarget = nil
            end
            task.wait(1)
        end
    end)()
end

-- Advanced Navigation System
function CalculateBoatRoute(startPos, endPos)
    local waypoints = {}
    local currentPos = startPos
    local direction = (endPos - startPos).Unit
    local totalDistance = (endPos - startPos).Magnitude
    
    -- Add main waypoints
    for i = 1, math.floor(totalDistance / 500) do
        local waypointPos = startPos + (direction * (i * 500))
        table.insert(waypoints, waypointPos)
    end
    
    -- Add final destination
    table.insert(waypoints, endPos)
    
    return waypoints
end

function NavigateUsingWaypoints(waypoints)
    if not CurrentBoat or #waypoints == 0 then return end
    
    local currentWaypoint = 1
    local waypointReachedDistance = 50
    
    while currentWaypoint <= #waypoints and Settings.AutoBoat do
        local targetPos = waypoints[currentWaypoint]
        local boatPos = CurrentBoat.Main.Position
        local distance = (boatPos - targetPos).Magnitude
        
        if distance <= waypointReachedDistance then
            currentWaypoint = currentWaypoint + 1
            if currentWaypoint <= #waypoints then
                Notify("Navigation", "Reached waypoint " .. (currentWaypoint - 1) .. "/" .. #waypoints, 2)
            end
        else
            -- Navigate to waypoint
            local direction = (targetPos - boatPos).Unit
            CurrentBoat.Main.Velocity = direction * Settings.BoatSpeed
            
            -- Avoid obstacles
            AvoidObstacles()
        end
        
        task.wait(0.1)
    end
    
    if currentWaypoint > #waypoints then
        Notify("Navigation", "Destination reached!", 3)
        Settings.AutoBoat = false
    end
end

-- Advanced Combat System
function ExecuteAdvancedCombo(target)
    if not target then return end
    
    local distance = (HumanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude
    local targetHealthPercent = target.Humanoid.Health / target.Humanoid.MaxHealth
    
    -- Choose combo based on distance and health
    if distance <= 10 then
        -- Close range combo
        ExecuteCloseRangeCombo()
    elseif distance <= 30 then
        -- Medium range combo
        ExecuteMediumRangeCombo()
    else
        -- Long range combo
        ExecuteLongRangeCombo()
    end
    
    -- Special moves for low health targets
    if targetHealthPercent < 0.3 then
        ExecuteFinishingCombo()
    end
end

function ExecuteCloseRangeCombo()
    -- M1 spam for close range
    for i = 1, 5 do
        VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
        task.wait(0.1)
    end
    
    -- Levi spin for AoE
    UseLeviSkill("Levi Spin")
    task.wait(0.5)
    
    -- Dash through enemy
    UseLeviSkill("Levi Dash")
end

function ExecuteMediumRangeCombo()
    -- Start with dash to close distance
    UseLeviSkill("Levi Dash")
    task.wait(0.3)
    
    -- Follow up with spin
    UseLeviSkill("Levi Spin")
    task.wait(0.3)
    
    -- Finish with flight
    UseLeviSkill("Levi Flight")
end

function ExecuteLongRangeCombo()
    -- Use flight to get closer
    UseLeviSkill("Levi Flight")
    task.wait(0.5)
    
    -- Vortex to pull enemies
    UseLeviSkill("Levi Vortex")
    task.wait(0.5)
    
    -- Finish with tsunami
    UseLeviSkill("Levi Tsunami")
end

function ExecuteFinishingCombo()
    -- Ultimate combo for finishing
    Notify("Combat", "Executing finishing combo!", 2)
    
    -- Dash in
    UseLeviSkill("Levi Dash")
    task.wait(0.2)
    
    -- Spin
    UseLeviSkill("Levi Spin")
    task.wait(0.2)
    
    -- Flight
    UseLeviSkill("Levi Flight")
    task.wait(0.2)
    
    -- Vortex
    UseLeviSkill("Levi Vortex")
    task.wait(0.5)
    
    -- Tsunami (if available)
    UseLeviSkill("Levi Tsunami")
end

-- Auto Skill Rotation System
function SetupSkillRotation()
    local skillRotation = {}
    
    if Settings.UseLeviDash then
        table.insert(skillRotation, "Levi Dash")
    end
    
    if Settings.UseLeviSpin then
        table.insert(skillRotation, "Levi Spin")
    end
    
    if Settings.UseLeviFlight then
        table.insert(skillRotation, "Levi Flight")
    end
    
    return skillRotation
end

function ExecuteSkillRotation()
    local skillRotation = SetupSkillRotation()
    
    for _, skillName in pairs(skillRotation) do
        if not Settings.AutoLevi then break end
        
        UseLeviSkill(skillName)
        task.wait(Settings.LeviSkillDelay)
    end
end

-- Player Status Monitoring
function MonitorPlayerStatus()
    coroutine.wrap(function()
        while true do
            -- Check health
            if Humanoid.Health < (Humanoid.MaxHealth * (Settings.RetreatHealth / 100)) then
                if Settings.AutoFarm or Settings.AutoLeviRaid then
                    Notify("Warning", "Health low! Retreating...", 3)
                    RetreatToSafeZone()
                end
            end
            
            -- Check energy (if applicable)
            if Settings.InfiniteEnergy then
                -- Refresh energy
                EnableInfiniteEnergy()
            end
            
            -- Anti-AFK
            if Settings.AntiAfk then
                VirtualInputManager:SendKeyEvent(true, "W", false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, "W", false, game)
            end
            
            task.wait(5)
        end
    end)()
end

function RetreatToSafeZone()
    -- Find nearest safe zone (town or spawn)
    local safeZones = {
        Vector3.new(-1258, 18, 398),   -- Starter Island
        Vector3.new(-604, 25, -475),   -- Fruit Dealer
        Vector3.new(0, 10, 0)          -- Default spawn
    }
    
    local nearestSafeZone = safeZones[1]
    local shortestDistance = math.huge
    
    for _, zone in pairs(safeZones) do
        local distance = (HumanoidRootPart.Position - zone).Magnitude
        if distance < shortestDistance then
            shortestDistance = distance
            nearestSafeZone = zone
        end
    end
    
    -- Teleport to safe zone
    HumanoidRootPart.CFrame = CFrame.new(nearestSafeZone)
    Notify("Retreat", "Retreated to safe zone", 3)
    
    -- Wait for health recovery
    task.wait(10)
    
    -- Heal if possible
    Humanoid.Health = Humanoid.MaxHealth
end

-- Item Management System
function ScanInventory()
    local inventory = {
        Swords = {},
        Fruits = {},
        Accessories = {},
        Materials = {}
    }
    
    -- Scan backpack
    local backpack = Player:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                if item.Name:find("Sword") or item.Name:find("Blade") then
                    table.insert(inventory.Swords, item)
                elseif item.Name:find("Fruit") then
                    table.insert(inventory.Fruits, item)
                elseif item.Name:find("Gun") then
                    table.insert(inventory.Guns, item)
                end
            end
        end
    end
    
    -- Scan character
    if Character then
        for _, item in pairs(Character:GetChildren()) do
            if item:IsA("Tool") then
                if item.Name:find("Sword") or item.Name:find("Blade") then
                    table.insert(inventory.Swords, item)
                elseif item.Name:find("Fruit") then
                    table.insert(inventory.Fruits, item)
                elseif item.Name:find("Gun") then
                    table.insert(inventory.Guns, item)
                end
            elseif item:IsA("Accessory") then
                table.insert(inventory.Accessories, item)
            end
        end
    end
    
    return inventory
end

function GetBestItemFromCategory(category)
    local inventory = ScanInventory()
    local items = inventory[category] or {}
    
    if #items == 0 then
        return nil
    end
    
    local bestItem = items[1]
    local bestValue = 0
    
    for _, item in pairs(items) do
        local value = CalculateItemValue(item)
        if value > bestValue then
            bestValue = value
            bestItem = item
        end
    end
    
    return bestItem
end

function CalculateItemValue(item)
    local value = 0
    
    -- Base value from attributes
    local damage = item:GetAttribute("Damage") or 0
    local level = item:GetAttribute("Level") or 0
    local rarity = item:GetAttribute("Rarity") or 1
    
    value = damage + (level * 10) + (rarity * 100)
    
    -- Additional value for special properties
    if item.Name:find("Legendary") or item.Name:find("Mythical") then
        value = value * 2
    end
    
    return value
end

function AutoEquipBestItems()
    local inventory = ScanInventory()
    
    -- Equip best sword
    if #inventory.Swords > 0 then
        local bestSword = GetBestItemFromCategory("Swords")
        if bestSword then
            Humanoid:EquipTool(bestSword)
        end
    end
    
    -- Equip best fruit
    if #inventory.Fruits > 0 then
        local bestFruit = GetBestItemFromCategory("Fruits")
        if bestFruit then
            Humanoid:EquipTool(bestFruit)
        end
    end
    
    Notify("Inventory", "Auto-equipped best items", 3)
end

-- Quest System Integration
function CheckAvailableQuests()
    local quests = {}
    
    -- Look for quest NPCs
    for _, npc in pairs(Workspace.NPCs:GetChildren()) do
        if npc:FindFirstChild("Quest") or npc.Name:find("Quest") then
            table.insert(quests, {
                NPC = npc,
                Position = npc.Position,
                Type = "Standard"
            })
        end
    end
    
    return quests
end

function AutoAcceptQuests()
    coroutine.wrap(function()
        while Settings.AutoAcceptQuests do
            local quests = CheckAvailableQuests()
            
            for _, quest in pairs(quests) do
                -- Teleport to NPC
                HumanoidRootPart.CFrame = CFrame.new(quest.Position)
                task.wait(2)
                
                -- Click NPC
                if quest.NPC:FindFirstChild("Click") then
                    fireclickdetector(quest.NPC.Click)
                    task.wait(1)
                    
                    -- Try to accept quest
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, "E", false, game)
                    task.wait(0.1)
                    game:GetService("VirtualInputManager"):SendKeyEvent(false, "E", false, game)
                    
                    Notify("Quest", "Accepted quest from " .. quest.NPC.Name, 3)
                end
                
                task.wait(2)
            end
            
            task.wait(30) -- Check every 30 seconds
        end
    end)()
end

-- Boss Notifier System
function SetupBossNotifications()
    local bossNames = {
        "Tiki King",
        "Hydra Queen", 
        "Shark King",
        "Ice King",
        "Desert King",
        "Leviathan",
        "Sea Beast"
    }
    
    local function checkForBosses()
        for _, bossName in pairs(bossNames) do
            for _, mob in pairs(Workspace.Enemies:GetChildren()) do
                if mob.Name:find(bossName) and mob.Humanoid.Health > 0 then
                    Notify("BOSS SPAWNED!", bossName .. " has appeared!", 10)
                    
                    -- Optionally teleport to boss
                    if Settings.AutoTeleportToBoss then
                        TeleportToBoss(mob)
                    end
                    
                    break
                end
            end
        end
    end
    
    -- Periodic boss check
    local bossCheckConnection
    bossCheckConnection = RunService.Heartbeat:Connect(function()
        checkForBosses()
        task.wait(10) -- Check every 10 seconds
    end)
    
    return bossCheckConnection
end

function TeleportToBoss(boss)
    if not boss or not boss:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local bossPos = boss.HumanoidRootPart.Position
    HumanoidRootPart.CFrame = CFrame.new(bossPos + Vector3.new(0, 10, 0))
    Notify("Boss", "Teleported to " .. boss.Name, 3)
end

-- Performance Optimizer
function OptimizePerformance()
    if Settings.LowGraphics then
        -- Reduce graphics settings
        settings().Rendering.QualityLevel = 1
        settings().Rendering.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level04
        settings().Rendering.EagerBulkExecution = true
        
        -- Disable expensive effects
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 1000
        
        -- Remove particles
        for _, instance in pairs(Workspace:GetDescendants()) do
            if instance:IsA("ParticleEmitter") or
               instance:IsA("Trail") or
               instance:IsA("Beam") then
                instance:Destroy()
            end
        end
    end
    
    if Settings.RemoveEffects then
        -- Remove visual effects
        for _, effect in pairs(Workspace:GetDescendants()) do
            if effect:IsA("Fire") or
               effect:IsA("Smoke") or
               effect:IsA("Sparkles") or
               effect:IsA("PointLight") then
                effect:Destroy()
            end
        end
    end
end

-- Auto Update System
function CheckForUpdates()
    local version = "5.0"
    local updateUrl = "https://raw.githubusercontent.com/AstraHub/Scripts/main/version.json"
    
    local success, response = pcall(function()
        return game:HttpGet(updateUrl)
    end)
    
    if success then
        local updateInfo = HttpService:JSONDecode(response)
        if updateInfo.version > version then
            Notify("UPDATE AVAILABLE!", "New version " .. updateInfo.version .. " available!", 10)
            Notify("Update", "Changelog: " .. updateInfo.changelog, 10)
        end
    end
end

-- Keybind System
function SetupKeybinds()
    -- Toggle UI
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.KeyCode == Enum.KeyCode.RightControl then
                OrionLib:ToggleUI()
            elseif input.KeyCode == Enum.KeyCode.Insert then
                OrionLib:ToggleUI()
            end
            
            -- Quick skill keys
            if Settings.QuickSkillKeys then
                if input.KeyCode == Enum.KeyCode.One then
                    UseLeviSkill("Levi Dash")
                elseif input.KeyCode == Enum.KeyCode.Two then
                    UseLeviSkill("Levi Spin")
                elseif input.KeyCode == Enum.KeyCode.Three then
                    UseLeviSkill("Levi Flight")
                elseif input.KeyCode == Enum.KeyCode.Four then
                    UseLeviSkill("Levi Vortex")
                elseif input.KeyCode == Enum.KeyCode.Five then
                    UseLeviSkill("Levi Tsunami")
                end
            end
        end
    end)
end

-- Statistics Tracker
local Statistics = {
    MobsKilled = 0,
    BossesKilled = 0,
    ChestsOpened = 0,
    FruitsCollected = 0,
    BeliEarned = 0,
    TimePlayed = 0,
    DistanceTraveled = 0
}

function TrackStatistics()
    local startTime = tick()
    local lastPosition = HumanoidRootPart.Position
    
    -- Mob kill tracking
    local mobDiedConnection
    mobDiedConnection = workspace.Enemies.ChildRemoved:Connect(function(mob)
        if mob:FindFirstChild("Humanoid") then
            Statistics.MobsKilled = Statistics.MobsKilled + 1
            
            if mob.Name:find("Boss") or mob.Name:find("King") or mob.Name:find("Queen") then
                Statistics.BossesKilled = Statistics.BossesKilled + 1
                Notify("Statistics", "Boss defeated! Total: " .. Statistics.BossesKilled, 3)
            end
        end
    end)
    
    -- Distance tracking
    local distanceConnection
    distanceConnection = RunService.Heartbeat:Connect(function()
        local currentPosition = HumanoidRootPart.Position
        local distance = (currentPosition - lastPosition).Magnitude
        Statistics.DistanceTraveled = Statistics.DistanceTraveled + distance
        lastPosition = currentPosition
        
        -- Update time played
        Statistics.TimePlayed = tick() - startTime
    end)
    
    return {mobDiedConnection, distanceConnection}
end

function DisplayStatistics()
    local statsTab = Window:MakeTab({
        Name = "Statistics",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    statsTab:AddSection({
        Name = "Game Statistics"
    })
    
    statsTab:AddLabel("Mobs Killed: " .. Statistics.MobsKilled)
    statsTab:AddLabel("Bosses Killed: " .. Statistics.BossesKilled)
    statsTab:AddLabel("Chests Opened: " .. Statistics.ChestsOpened)
    statsTab:AddLabel("Fruits Collected: " .. Statistics.FruitsCollected)
    statsTab:AddLabel("Beli Earned: $" .. Statistics.BeliEarned)
    
    local timePlayed = string.format("%.1f", Statistics.TimePlayed / 60) .. " minutes"
    statsTab:AddLabel("Time Played: " .. timePlayed)
    
    local distance = string.format("%.0f", Statistics.DistanceTraveled) .. " studs"
    statsTab:AddLabel("Distance Traveled: " .. distance)
    
    statsTab:AddSection({
        Name = "Performance"
    })
    
    local fps = 0
    local fpsConnection
    fpsConnection = RunService.RenderStepped:Connect(function()
        fps = 1 / RunService.RenderStepped:Wait()
    end)
    
    statsTab:AddLabel("FPS: " .. string.format("%.0f", fps))
    statsTab:AddLabel("Ping: " .. string.format("%.0f", game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()) .. " ms")
    
    statsTab:AddButton({
        Name = "Refresh Statistics",
        Callback = function()
            DisplayStatistics()
        end
    })
    
    statsTab:AddButton({
        Name = "Reset Statistics",
        Callback = function()
            Statistics = {
                MobsKilled = 0,
                BossesKilled = 0,
                ChestsOpened = 0,
                FruitsCollected = 0,
                BeliEarned = 0,
                TimePlayed = 0,
                DistanceTraveled = 0
            }
            DisplayStatistics()
        end
    })
    
    table.insert(ESPObjects, fpsConnection)
end

-- Safety Features
function SafetyChecks()
    -- Check if player is in safe zone before aggressive actions
    local function isInSafeZone()
        local safeZonePositions = {
            Vector3.new(-1258, 18, 398),   -- Starter Island
            Vector3.new(-604, 25, -475),   -- Fruit Dealer
            Vector3.new(0, 10, 0)          -- Default spawn
        }
        
        for _, zone in pairs(safeZonePositions) do
            if (HumanoidRootPart.Position - zone).Magnitude < 100 then
                return true
            end
        end
        
        return false
    end
    
    -- Prevent farming in safe zones
    if Settings.AutoFarm and isInSafeZone() then
        Notify("Safety", "Auto Farm disabled in safe zone", 3)
        Settings.AutoFarm = false
    end
    
    -- Prevent Levi skills in safe zones
    if Settings.AutoLevi and isInSafeZone() then
        Notify("Safety", "Levi skills disabled in safe zone", 3)
        Settings.AutoLevi = false
    end
end

-- Initialize Everything
function InitializeScript()
    Notify("Astra Hub", "Levi Script v5.0 Loaded!", 5)
    
    -- Load settings
    if isfile("AstraHub_Levi_Settings.json") then
        LoadSettings()
    end
    
    -- Setup keybinds
    SetupKeybinds()
    
    -- Start monitoring
    MonitorPlayerStatus()
    
    -- Setup boss notifications
    local bossNotifier = SetupBossNotifications()
    table.insert(ESPObjects, bossNotifier)
    
    -- Start statistics tracking
    local statConnections = TrackStatistics()
    for _, conn in pairs(statConnections) do
        table.insert(ESPObjects, conn)
    end
    
    -- Display statistics tab
    DisplayStatistics()
    
    -- Optimize performance
    OptimizePerformance()
    
    -- Check for updates
    CheckForUpdates()
    
    -- Anti-AFK
    if Settings.AntiAfk then
        game:GetService("Players").LocalPlayer.Idled:Connect(function()
            VirtualInputManager:SendKeyEvent(true, "W", false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, "W", false, game)
        end)
    end
    
    Notify("System", "All systems initialized successfully!", 3)
end

-- Error Handling
local function SafeCall(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        Notify("Error", "Script error: " .. result, 5)
        return nil
    end
    return result
end

-- Main execution
coroutine.wrap(function()
    task.wait(2) -- Wait for game to load
    
    -- Initialize character references
    repeat
        Character = Player.Character or Player.CharacterAdded:Wait()
        task.wait(0.5)
    until Character and Character:FindFirstChild("HumanoidRootPart")
    
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    Humanoid = Character:WaitForChild("Humanoid")
    Mouse = Player:GetMouse()
    
    -- Initialize script
    SafeCall(InitializeScript)
    
    -- Safety checks loop
    while true do
        SafeCall(SafetyChecks)
        task.wait(5)
    end
end)()

-- Cleanup on script termination
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(newChar)
    Character = newChar
    HumanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
    Humanoid = newChar:WaitForChild("Humanoid")
end)

-- Script termination handler
local function Cleanup()
    -- Stop all loops
    if FarmLoop then FarmLoop:Disconnect() end
    if LeviLoop then LeviLoop:Disconnect() end
    if BoatLoop then BoatLoop:Disconnect() end
    if RaidLoop then RaidLoop:Disconnect() end
    if IslandLoop then IslandLoop:Disconnect() end
    
    -- Remove ESP
    DisableESP()
    
    -- Reset settings
    for _, obj in pairs(ESPObjects) do
        if obj and (obj:IsA("RBXScriptConnection") or obj:IsA("Instance")) then
            obj:Disconnect()
        end
    end
    
    ESPObjects = {}
    
    Notify("Script", "Cleanup completed", 3)
end

-- Connect cleanup to game closing
game:GetService("UserInputService").WindowFocused:Connect(function()
    -- Save settings when window gains focus
    if Settings.SaveSettings then
        SaveSettings()
    end
end)

-- Final initialization
OrionLib:Init()

-- Create watermark
local Watermark = Instance.new("ScreenGui")
Watermark.Name = "AstraHubWatermark"
Watermark.Parent = game:GetService("CoreGui")
Watermark.ResetOnSpawn = false

local WatermarkFrame = Instance.new("Frame")
WatermarkFrame.Size = UDim2.new(0, 200, 0, 30)
WatermarkFrame.Position = UDim2.new(0.5, -100, 0, 10)
WatermarkFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
WatermarkFrame.BackgroundTransparency = 0.3
WatermarkFrame.BorderSizePixel = 0
WatermarkFrame.Parent = Watermark

local WatermarkLabel = Instance.new("TextLabel")
WatermarkLabel.Size = UDim2.new(1, 0, 1, 0)
WatermarkLabel.BackgroundTransparency = 1
WatermarkLabel.Text = "Astra Hub | Levi"
WatermarkLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
WatermarkLabel.TextSize = 14
WatermarkLabel.Font = Enum.Font.GothamBold
WatermarkLabel.Parent = WatermarkFrame

-- Toggle watermark
function ToggleWatermark(show)
    Watermark.Enabled = show
end

-- Initial notifications
task.wait(1)
Notify("Welcome " .. Player.Name .. "!", "Level: " .. GetPlayerLevel() .. " | Beli: $" .. GetPlayerBeli(), 5)
Notify("Controls", "RightCtrl/Insert to toggle UI | 1-5 for quick skills", 5)
Notify("Reminder", "Use responsibly! Script for educational purposes.", 5)

-- Auto-save settings
coroutine.wrap(function()
    while true do
        task.wait(60) -- Auto-save every minute
        if Settings.SaveSettings then
            SaveSettings()
        end
    end
end)()

-- Server player count monitor
coroutine.wrap(function()
    while true do
        task.wait(30)
        if Settings.ServerHopOnLowPlayers then
            local playerCount = #Players:GetPlayers()
            if playerCount < Settings.MinimumPlayers then
                Notify("Server", "Low player count (" .. playerCount .. "). Server hopping...", 3)
                ServerHop()
            end
        end
    end
end)()

-- Final message
print("LoadingScripts 1%")
print("LoadingScripts ...")
print("Player: " .. Player.Name)
print("Level: " .. GetPlayerLevel())
print("Beli: $" .. GetPlayerBeli())

-- Auto Island Farming System
function StartIslandFarming(islandName)
    local islandData = IslandLocations[islandName]
    if not islandData then
        Notify("Island System", "Island data not found: " .. islandName, 3)
        return
    end
    
    Settings["Auto" .. islandName:gsub(" ", "")] = true
    
    coroutine.wrap(function()
        Notify("Island System", "Starting " .. islandName .. " farming...", 3)
        
        -- Phase 1: Transport to island
        local onIsland, currentIsland = IsPlayerInIsland()
        if not onIsland or currentIsland ~= islandName then
            Notify("Island System", "Transporting to " .. islandName + "...", 3)
            
            -- Use boat system
            if not CurrentBoat then
                SpawnBoat()
                task.wait(3)
            end
            
            DriveBoatToIsland(islandName)
            
            -- Wait for arrival
            local arrivalTimeout = 60
            local startTime = tick()
            while tick() - startTime < arrivalTimeout do
                onIsland, currentIsland = IsPlayerInIsland()
                if onIsland and currentIsland == islandName then
                    break
                end
                task.wait(2)
            end
            
            if not onIsland or currentIsland ~= islandName then
                Notify("Island System", "Failed to reach " .. islandName, 3)
                return
            end
        end
        
        -- Phase 2: Island farming loop
        while Settings["Auto" .. islandName:gsub(" ", "")] do
            ExecuteIslandFarmingCycle(islandName, islandData)
            task.wait(2)
        end
        
        Notify("Island System", islandName .. " farming stopped", 3)
    end)()
end

function ExecuteIslandFarmingCycle(islandName, islandData)
    -- Check player status
    if Humanoid.Health <= 0 then
        Notify("Island System", "Player died, respawning...", 3)
        task.wait(5)
        return
    end
    
    local farmMode = Settings.IslandFarmMode
    
    if farmMode == "Mobs" or farmMode == "All" then
        FarmIslandMobs(islandData)
    end
    
    if farmMode == "Boss" or farmMode == "All" then
        FarmIslandBoss(islandData)
    end
    
    if farmMode == "Chests" or farmMode == "All" then
        CollectIslandChests(islandData)
    end
    
    if farmMode == "Resources" or farmMode == "All" then
        CollectIslandResources(islandData)
    end
    
    -- Special collections
    if islandName == "Tiki Island" and Settings.CollectTikiTotems then
        CollectSpecialItems(islandData.Totems, "Totem")
    end
    
    if islandName == "Hydra Island" and Settings.CollectHydraScales then
        CollectSpecialItems(islandData.Scales, "Scale")
    end
end

function FarmIslandMobs(islandData)
    local mobs = GetIslandMobs(islandData)
    
    if #mobs == 0 then
        return
    end
    
    -- Sort by priority
    if Settings.MobPriority == "Nearest" then
        table.sort(mobs, function(a, b)
            local distA = (HumanoidRootPart.Position - a.HumanoidRootPart.Position).Magnitude
            local distB = (HumanoidRootPart.Position - b.HumanoidRootPart.Position).Magnitude
            return distA < distB
        end)
    elseif Settings.MobPriority == "Highest Level" then
        table.sort(mobs, function(a, b)
            local levelA = a:GetAttribute("Level") or 0
            local levelB = b:GetAttribute("Level") or 0
            return levelA > levelB
        end)
    end
    
    -- Farm mobs
    for _, mob in pairs(mobs) do
        if not Settings.AutoTikiIsland and not Settings.AutoHydraIsland then
            break
        end
        
        if mob and mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            FarmTarget(mob)
            task.wait(0.3)
        end
    end
end

function GetIslandMobs(islandData)
    local islandMobs = {}
    
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            for _, mobType in pairs(islandData.Mobs) do
                if mob.Name:find(mobType) then
                    table.insert(islandMobs, mob)
                    break
                end
            end
        end
    end
    
    return islandMobs
end

function FarmIslandBoss(islandData)
    local bossName = islandData.Boss
    local bossPosition = islandData.BossPosition
    
    -- Check if boss exists and is alive
    local boss = nil
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob.Name:find(bossName) and mob.Humanoid.Health > 0 then
            boss = mob
            break
        end
    end
    
    if not boss then
        -- Boss not found, go to boss area
        HumanoidRootPart.CFrame = CFrame.new(bossPosition)
        task.wait(2)
        
        -- Check again
        for _, mob in pairs(Workspace.Enemies:GetChildren()) do
            if mob.Name:find(bossName) and mob.Humanoid.Health > 0 then
                boss = mob
                break
            end
        end
    end
    
    if boss then
        -- Farm boss
        while boss and boss.Humanoid.Health > 0 and 
              (Settings.AutoTikiIsland or Settings.AutoHydraIsland) do
            FarmTarget(boss)
            task.wait(0.5)
        end
        
        if boss and boss.Humanoid.Health <= 0 then
            Notify("Boss", bossName .. " defeated!", 5)
            Statistics.BossesKilled = Statistics.BossesKilled + 1
        end
    end
end

function CollectIslandChests(islandData)
    for _, chestType in pairs(islandData.Chests) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(chestType) then
                local distance = (HumanoidRootPart.Position - obj.Position).Magnitude
                if distance < 200 then
                    -- Teleport to chest
                    HumanoidRootPart.CFrame = CFrame.new(obj.Position)
                    task.wait(1)
                    
                    -- Open chest
                    if obj:FindFirstChild("Click") then
                        fireclickdetector(obj.Click)
                        Statistics.ChestsOpened = Statistics.ChestsOpened + 1
                        Notify("Chest", "Opened " .. chestType, 2)
                    end
                    
                    task.wait(2)
                end
            end
        end
    end
end

function CollectIslandResources(islandData)
    for _, resourceType in pairs(islandData.Resources) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(resourceType) then
                local part = obj:IsA("Model") and obj.PrimaryPart or obj
                if part then
                    local distance = (HumanoidRootPart.Position - part.Position).Magnitude
                    if distance < 100 then
                        -- Teleport to resource
                        HumanoidRootPart.CFrame = CFrame.new(part.Position)
                        task.wait(1)
                        
                        -- Collect resource
                        firetouchinterest(HumanoidRootPart, part, 0)
                        task.wait(0.1)
                        firetouchinterest(HumanoidRootPart, part, 1)
                        
                        Notify("Resource", "Collected " .. resourceType, 2)
                        task.wait(1)
                    end
                end
            end
        end
    end
end

function CollectSpecialItems(itemList, itemType)
    for _, itemName in pairs(itemList) do
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj.Name:find(itemName) then
                local part = obj:IsA("Model") and obj.PrimaryPart or obj
                if part then
                    local distance = (HumanoidRootPart.Position - part.Position).Magnitude
                    if distance < 150 then
                        -- Teleport to item
                        HumanoidRootPart.CFrame = CFrame.new(part.Position)
                        task.wait(1)
                        
                        -- Collect item
                        if obj:FindFirstChild("Click") then
                            fireclickdetector(obj.Click)
                        else
                            firetouchinterest(HumanoidRootPart, part, 0)
                            task.wait(0.1)
                            firetouchinterest(HumanoidRootPart, part, 1)
                        end
                        
                        Notify(itemType, "Collected " .. itemName, 2)
                        task.wait(1)
                    end
                end
            end
        end
    end
end

-- Advanced Auto Buy System
local AutoBuyQueue = {}
local CurrentlyBuying = false

function AddToBuyQueue(itemName, priority)
    if not BuyableItems[itemName] then
        Notify("Auto Buy", "Item not in database: " .. itemName, 3)
        return false
    end
    
    -- Check if already in queue
    for _, item in pairs(AutoBuyQueue) do
        if item.Name == itemName then
            Notify("Auto Buy", itemName .. " already in queue", 3)
            return false
        end
    end
    
    table.insert(AutoBuyQueue, {
        Name = itemName,
        Priority = priority or 1,
        Attempts = 0,
        LastAttempt = 0
    })
    
    -- Sort queue by priority
    table.sort(AutoBuyQueue, function(a, b)
        return a.Priority > b.Priority
    end)
    
    Notify("Auto Buy", "Added " .. itemName .. " to buy queue", 3)
    return true
end

function RemoveFromBuyQueue(itemName)
    for i, item in pairs(AutoBuyQueue) do
        if item.Name == itemName then
            table.remove(AutoBuyQueue, i)
            Notify("Auto Buy", "Removed " .. itemName .. " from queue", 3)
            return true
        end
    end
    return false
end

function ProcessBuyQueue()
    if CurrentlyBuying or #AutoBuyQueue == 0 then
        return
    end
    
    CurrentlyBuying = true
    
    coroutine.wrap(function()
        while #AutoBuyQueue > 0 and Settings.AutoBuyLeviChip do
            local item = AutoBuyQueue[1]
            local itemData = BuyableItems[item.Name]
            
            -- Check requirements
            local playerLevel = GetPlayerLevel()
            local playerBeli = GetPlayerBeli()
            
            if playerBeli >= itemData.Price then
                -- Attempt purchase
                local success = AutoBuyItem(item.Name)
                
                if success then
                    -- Remove from queue
                    table.remove(AutoBuyQueue, 1)
                    Notify("Auto Buy", "Successfully purchased " .. item.Name, 3)
                else
                    -- Increment attempts
                    item.Attempts = item.Attempts + 1
                    item.LastAttempt = tick()
                    
                    if item.Attempts >= 3 then
                        -- Too many failures, remove from queue
                        table.remove(AutoBuyQueue, 1)
                        Notify("Auto Buy", "Failed to purchase " .. item.Name .. " after 3 attempts", 3)
                    else
                        -- Move to end of queue
                        table.remove(AutoBuyQueue, 1)
                        table.insert(AutoBuyQueue, item)
                    end
                end
            else
                -- Not enough money, move to end
                table.remove(AutoBuyQueue, 1)
                table.insert(AutoBuyQueue, item)
                
                Notify("Auto Buy", "Insufficient funds for " .. item.Name .. ": $" .. itemData.Price, 3)
            end
            
            task.wait(5) -- Wait between purchase attempts
        end
        
        CurrentlyBuying = false
    end)()
end

function StartSmartAutoBuy()
    coroutine.wrap(function()
        while Settings.AutoBuyLeviChip do
            -- Check player level and funds
            local playerLevel = GetPlayerLevel()
            local playerBeli = GetPlayerBeli()
            
            -- Determine what to buy based on level
            if playerLevel >= 1000 and playerBeli >= 1000000 then
                AddToBuyQueue("Levi Chip", 10) -- Highest priority
            end
            
            if playerLevel >= 800 and playerBeli >= 1200000 then
                AddToBuyQueue("Dual Katana", 9)
            end
            
            if playerBeli >= 25000 then
                AddToBuyQueue("Iron Mace", 8)
            end
            
            if playerBeli >= 10000 then
                AddToBuyQueue("Katana", 7)
            end
            
            if playerBeli >= 50000 then
                AddToBuyQueue("Bomb Fruit", 6)
            end
            
            if playerBeli >= 100000 then
                AddToBuyQueue("Spike Fruit", 5)
            end
            
            -- Process queue
            ProcessBuyQueue()
            
            task.wait(30) -- Check every 30 seconds
        end
    end)()
end

-- Inventory Management System
function GetInventoryValue()
    local totalValue = 0
    local inventory = ScanInventory()
    
    -- Calculate sword value
    for _, sword in pairs(inventory.Swords) do
        totalValue = totalValue + CalculateItemValue(sword)
    end
    
    -- Calculate fruit value
    for _, fruit in pairs(inventory.Fruits) do
        totalValue = totalValue + CalculateItemValue(fruit)
    end
    
    -- Calculate accessory value
    for _, accessory in pairs(inventory.Accessories) do
        totalValue = totalValue + (accessory:GetAttribute("Value") or 1000)
    end
    
    return totalValue
end

function OptimizeInventory()
    local inventory = ScanInventory()
    
    -- Sort swords by value
    table.sort(inventory.Swords, function(a, b)
        return CalculateItemValue(a) > CalculateItemValue(b)
    end)
    
    -- Keep only top 3 swords (if auto-selling lower ones)
    if Settings.AutoSell then
        for i = 4, #inventory.Swords do
            local sword = inventory.Swords[i]
            if sword then
                -- Mark for selling
                MarkItemForSale(sword)
            end
        end
    end
    
    -- Equip best sword
    if #inventory.Swords > 0 then
        Humanoid:EquipTool(inventory.Swords[1])
    end
    
    -- Equip best fruit
    if #inventory.Fruits > 0 then
        table.sort(inventory.Fruits, function(a, b)
            return CalculateItemValue(a) > CalculateItemValue(b)
        end)
        Humanoid:EquipTool(inventory.Fruits[1])
    end
    
    Notify("Inventory", "Inventory optimized", 3)
end

function MarkItemForSale(item)
    -- This would mark an item for sale in the auto-sell system
    item:SetAttribute("ForSale", true)
end

-- Advanced Combat AI
function GetOptimalAttackDistance(target)
    if not target then return 10 end
    
    local targetSize = target:GetExtentsSize().Magnitude
    local targetSpeed = target.Humanoid.WalkSpeed
    
    -- Calculate optimal distance based on target size and speed
    local optimalDistance = 10
    
    if targetSize > 20 then
        optimalDistance = 15 -- Larger targets need more distance
    end
    
    if targetSpeed > 50 then
        optimalDistance = optimalDistance + 5 -- Faster targets need more distance
    end
    
    return optimalDistance
end

function PredictTargetMovement(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then
        return Vector3.new(0, 0, 0)
    end
    
    local targetVelocity = target.HumanoidRootPart.Velocity
    local predictionTime = 0.5 -- Predict 0.5 seconds ahead
    
    return target.HumanoidRootPart.Position + (targetVelocity * predictionTime)
end

function AimAtPredictedPosition(target)
    local predictedPosition = PredictTargetMovement(target)
    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position, predictedPosition)
end

function ExecuteSmartCombo(target)
    if not target then return end
    
    local distance = (HumanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude
    local targetHealthPercent = target.Humanoid.Health / target.Humanoid.MaxHealth
    local optimalDistance = GetOptimalAttackDistance(target)
    
    -- Movement strategy
    if distance > optimalDistance then
        -- Move closer
        local direction = (target.HumanoidRootPart.Position - HumanoidRootPart.Position).Unit
        HumanoidRootPart.CFrame = CFrame.new(target.HumanoidRootPart.Position - (direction * optimalDistance))
    elseif distance < optimalDistance - 5 then
        -- Move back
        local direction = (HumanoidRootPart.Position - target.HumanoidRootPart.Position).Unit
        HumanoidRootPart.CFrame = CFrame.new(target.HumanoidRootPart.Position + (direction * optimalDistance))
    end
    
    -- Aim at predicted position
    AimAtPredictedPosition(target)
    
    -- Combo selection based on situation
    if targetHealthPercent > 0.7 then
        ExecuteOpeningCombo(target)
    elseif targetHealthPercent > 0.3 then
        ExecuteSustainedCombo(target)
    else
        ExecuteFinishingCombo(target)
    end
    
    -- Dodging
    if Settings.AutoDodge then
        CheckAndDodge(target)
    end
end

function ExecuteOpeningCombo(target)
    -- Opening combo for fresh targets
    UseLeviSkill("Levi Dash") -- Close distance quickly
    task.wait(0.3)
    UseLeviSkill("Levi Spin") -- AoE damage
    task.wait(0.3)
    
    -- Basic attacks
    for i = 1, 3 do
        VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
        task.wait(0.2)
    end
end

function ExecuteSustainedCombo(target)
    -- Sustained damage combo
    UseLeviSkill("Levi Flight") -- Position advantage
    task.wait(0.4)
    UseLeviSkill("Levi Vortex") -- CC and damage
    task.wait(0.4)
    
    -- Rapid attacks
    for i = 1, 5 do
        VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
        task.wait(0.15)
    end
end

function CheckAndDodge(target)
    -- Check if target is attacking
    if target:FindFirstChild("AttackIndicator") or target:FindFirstChild("ChargingAttack") then
        -- Dodge based on attack type
        local dodgeDirection = CalculateDodgeDirection(target)
        HumanoidRootPart.Velocity = dodgeDirection * 100
        
        Notify("Combat", "Dodging attack!", 1)
        task.wait(0.5)
        
        -- Reset velocity
        HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    end
end

function CalculateDodgeDirection(target)
    if not target then return Vector3.new(0, 1, 0) end
    
    local targetPos = target.HumanoidRootPart.Position
    local playerPos = HumanoidRootPart.Position
    local attackDirection = (playerPos - targetPos).Unit
    
    -- Dodge perpendicular to attack direction
    local dodgeDirection = attackDirection:Cross(Vector3.new(0, 1, 0))
    
    -- Add upward component
    dodgeDirection = dodgeDirection + Vector3.new(0, 0.5, 0)
    
    return dodgeDirection.Unit
end

-- Boat AI Enhancement
function GetBoatHealth()
    if not CurrentBoat then return 0 end
    
    local health = 100
    
    -- Check for damage indicators
    for _, part in pairs(CurrentBoat:GetDescendants()) do
        if part:IsA("BasePart") and part:GetAttribute("Damaged") then
            health = health - 10
        end
    end
    
    return math.max(0, health)
end

function RepairBoat()
    if not CurrentBoat then return false end
    
    local boatHealth = GetBoatHealth()
    
    if boatHealth < 50 then
        Notify("Boat", "Boat health low (" .. boatHealth .. "%), attempting repair...", 3)
        
        -- Look for repair stations
        for _, station in pairs(Workspace:GetDescendants()) do
            if station.Name:find("Repair") and station.Name:find("Station") then
                -- Navigate to repair station
                local waypoints = CalculateBoatRoute(CurrentBoat.Main.Position, station.Position)
                NavigateUsingWaypoints(waypoints)
                
                -- Wait for repair
                task.wait(5)
                
                -- Simulate repair
                if station:FindFirstChild("Click") then
                    fireclickdetector(station.Click)
                    Notify("Boat", "Boat repaired!", 3)
                    return true
                end
            end
        end
    end
    
    return false
end

function AvoidSeaHazards()
    if not CurrentBoat then return end
    
    local hazards = {
        "Whirlpool",
        "Storm",
        "Iceberg",
        "Rock",
        "Sea Mine"
    }
    
    local boatPos = CurrentBoat.Main.Position
    
    for _, hazardName in pairs(hazards) do
        for _, hazard in pairs(Workspace:GetDescendants()) do
            if hazard.Name:find(hazardName) then
                local hazardPos = hazard:IsA("Model") and hazard.PrimaryPart.Position or hazard.Position
                local distance = (boatPos - hazardPos).Magnitude
                
                if distance < 100 then
                    -- Calculate avoidance direction
                    local avoidanceDirection = (boatPos - hazardPos).Unit
                    CurrentBoat.Main.Velocity = avoidanceDirection * Settings.BoatSpeed
                    
                    Notify("Navigation", "Avoiding " .. hazardName, 2)
                    task.wait(2)
                    
                    return true
                end
            end
        end
    end
    
    return false
end

-- Advanced Levi Raid System
local LeviRaidPhases = {
    Phase1 = {
        Name = "Preparation",
        Objectives = {"Get to raid island", "Gather supplies", "Set up defenses"},
        TimeLimit = 300,
        Completed = false
    },
    Phase2 = {
        Name = "Leviathan Approach",
        Objectives = {"Spot Leviathan", "Prepare weapons", "Position boat"},
        TimeLimit = 180,
        Completed = false
    },
    Phase3 = {
        Name = "Combat Phase 1",
        Objectives = {"Attack Leviathan", "Dodge attacks", "Destroy weak points"},
        TimeLimit = 300,
        Completed = false
    },
    Phase4 = {
        Name = "Combat Phase 2",
        Objectives = {"Continue attack", "Avoid special attacks", "Heal if needed"},
        TimeLimit = 300,
        Completed = false
    },
    Phase5 = {
        Name = "Final Phase",
        Objectives = {"Finish Leviathan", "Collect rewards", "Escape if failing"},
        TimeLimit = 240,
        Completed = false
    }
}

function ExecuteLeviathanRaidPhase(phase)
    Notify("Leviathan Raid", "Starting " .. phase.Name, 3)
    
    local phaseStartTime = tick()
    
    while tick() - phaseStartTime < phase.TimeLimit and Settings.AutoLeviRaid do
        -- Execute phase-specific actions
        if phase.Name == "Preparation" then
            ExecuteRaidPreparation()
        elseif phase.Name == "Leviathan Approach" then
            ExecuteLeviathanApproach()
        elseif phase.Name:find("Combat Phase") then
            ExecuteCombatPhase(phase)
        elseif phase.Name == "Final Phase" then
            ExecuteFinalPhase()
        end
        
        -- Check phase completion
        if CheckPhaseCompletion(phase) then
            phase.Completed = true
            Notify("Leviathan Raid", phase.Name .. " completed!", 3)
            break
        end
        
        task.wait(1)
    end
    
    if not phase.Completed then
        Notify("Leviathan Raid", phase.Name .. " failed or timed out", 3)
    end
end

function ExecuteRaidPreparation()
    -- Spawn or locate boat
    if not CurrentBoat then
        SpawnBoat()
        task.wait(3)
    end
    
    -- Load boat with supplies (simulated)
    Notify("Raid", "Loading supplies...", 2)
    task.wait(2)
    
    -- Navigate to raid area
    local raidPosition = Vector3.new(-4600, 100, -250)
    if CurrentBoat then
        local waypoints = CalculateBoatRoute(CurrentBoat.Main.Position, raidPosition)
        NavigateUsingWaypoints(waypoints)
    else
        HumanoidRootPart.CFrame = CFrame.new(raidPosition)
    end
    
    task.wait(5)
end

function ExecuteLeviathanApproach()
    -- Look for Leviathan
    local leviathan = FindLeviathan()
    
    if leviathan then
        -- Approach cautiously
        local safeDistance = 150
        local leviathanPos = leviathan.HumanoidRootPart.Position
        
        if CurrentBoat then
            local boatPos = CurrentBoat.Main.Position
            local distance = (boatPos - leviathanPos).Magnitude
            
            if distance > safeDistance then
                -- Approach to safe distance
                local approachDirection = (leviathanPos - boatPos).Unit
                CurrentBoat.Main.Velocity = approachDirection * (Settings.BoatSpeed * 0.7)
            else
                -- Maintain distance
                CurrentBoat.Main.Velocity = Vector3.new(0, 0, 0)
            end
        end
        
        -- Prepare weapons
        EquipBestWeapon("Sword")
        EquipBestWeapon("Fruit")
        
        Notify("Raid", "Leviathan spotted! Preparing for combat...", 3)
    else
        -- Search for Leviathan
        Notify("Raid", "Searching for Leviathan...", 2)
        SearchForLeviathan()
    end
end

function ExecuteCombatPhase(phase)
    local leviathan = FindLeviathan()
    
    if not leviathan then
        Notify("Raid", "Leviathan not found!", 3)
        return
    end
    
    -- Combat tactics based on phase
    if phase.Name == "Combat Phase 1" then
        ExecutePhase1Combat(leviathan)
    elseif phase.Name == "Combat Phase 2" then
        ExecutePhase2Combat(leviathan)
    end
    
    -- Collect hearts if enabled
    if Settings.AutoCollectLeviHearts then
        CollectLeviHearts()
    end
end

function ExecutePhase1Combat(leviathan)
    -- Basic attack pattern
    local attackPattern = {
        "Levi Dash",
        "Levi Spin",
        "Basic Attack",
        "Levi Flight"
    }
    
    for _, attack in pairs(attackPattern) do
        if not Settings.AutoLeviRaid then break end
        
        if attack == "Basic Attack" then
            for i = 1, 5 do
                VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
                task.wait(0.1)
            end
        else
            UseLeviSkill(attack)
        end
        
        -- Dodging
        if Settings.AutoDodge then
            CheckAndDodge(leviathan)
        end
        
        task.wait(1)
    end
end

function ExecutePhase2Combat(leviathan)
    -- Advanced attack pattern
    local comboPatterns = {
        {"Levi Dash", "Levi Spin", "Levi Vortex"},
        {"Levi Flight", "Basic Attack", "Levi Spin"},
        {"Levi Vortex", "Levi Dash", "Levi Flight"}
    }
    
    local randomPattern = comboPatterns[math.random(1, #comboPatterns)]
    
    for _, attack in pairs(randomPattern) do
        if not Settings.AutoLeviRaid then break end
        
        if attack == "Basic Attack" then
            ExecuteRapidAttackCombo()
        else
            UseLeviSkill(attack)
        end
        
        -- Advanced dodging
        ExecuteAdvancedDodge(leviathan)
        
        task.wait(1)
    end
end

function ExecuteFinalPhase()
    local leviathan = FindLeviathan()
    
    if not leviathan then
        Notify("Raid", "Leviathan defeated or escaped!", 3)
        return
    end
    
    -- All-out attack
    Notify("Raid", "FINAL PHASE! All-out attack!", 3)
    
    -- Use all skills in rapid succession
    local allSkills = {"Levi Dash", "Levi Spin", "Levi Flight", "Levi Vortex", "Levi Tsunami"}
    
    for _, skill in pairs(allSkills) do
        UseLeviSkill(skill)
        task.wait(0.5)
    end
    
    -- Spam basic attacks
    for i = 1, 10 do
        VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
        task.wait(0.05)
    end
    
    -- Check if Leviathan is defeated
    if leviathan.Humanoid.Health <= 0 then
        Notify("Raid", "LEVIATHAN DEFEATED! VICTORY!", 5)
        CollectRaidRewards()
    else
        Notify("Raid", "Leviathan still standing...", 3)
    end
end

function CheckPhaseCompletion(phase)
    if phase.Name == "Preparation" then
        -- Check if at raid location with boat
        local atRaidLocation = (HumanoidRootPart.Position - Vector3.new(-4600, 100, -250)).Magnitude < 200
        return atRaidLocation and CurrentBoat ~= nil
    elseif phase.Name == "Leviathan Approach" then
        -- Check if Leviathan is found and in range
        local leviathan = FindLeviathan()
        return leviathan ~= nil
    elseif phase.Name:find("Combat Phase") then
        -- Check if Leviathan health reduced by phase amount
        local leviathan = FindLeviathan()
        if not leviathan then return true end -- Leviathan defeated
        
        local healthPercent = leviathan.Humanoid.Health / leviathan.Humanoid.MaxHealth
        
        if phase.Name == "Combat Phase 1" then
            return healthPercent <= 0.7
        elseif phase.Name == "Combat Phase 2" then
            return healthPercent <= 0.3
        end
    elseif phase.Name == "Final Phase" then
        -- Check if Leviathan defeated
        local leviathan = FindLeviathan()
        return leviathan == nil or leviathan.Humanoid.Health <= 0
    end
    
    return false
end

function SearchForLeviathan()
    -- Search pattern positions
    local searchPositions = {
        Vector3.new(-4600, 100, -250),
        Vector3.new(-4800, 100, -500),
        Vector3.new(-4400, 100, -500),
        Vector3.new(-4600, 100, -750),
        Vector3.new(-4800, 100, -1000)
    }
    
    for _, searchPos in pairs(searchPositions) do
        if not Settings.AutoLeviRaid then break end
        
        -- Navigate to search position
        if CurrentBoat then
            local waypoints = CalculateBoatRoute(CurrentBoat.Main.Position, searchPos)
            NavigateUsingWaypoints(waypoints)
        else
            HumanoidRootPart.CFrame = CFrame.new(searchPos)
        end
        
        task.wait(5)
        
        -- Check for Leviathan
        if FindLeviathan() then
            return true
        end
    end
    
    return false
end

function ExecuteRapidAttackCombo()
    for i = 1, 8 do
        VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
        task.wait(0.05)
    end
end

function ExecuteAdvancedDodge(target)
    if not target then return end
    
    -- Predict attack based on target animation
    if target:FindFirstChild("AttackAnimation") or target.Humanoid:GetState() == Enum.HumanoidStateType.Attacking then
        -- Complex dodge pattern
        local dodgePatterns = {
            Vector3.new(1, 0.5, 0),   -- Right and up
            Vector3.new(-1, 0.5, 0),  -- Left and up
            Vector3.new(0, 1, 1),     -- Up and forward
            Vector3.new(0, 1, -1)     -- Up and backward
        }
        
        local randomPattern = dodgePatterns[math.random(1, #dodgePatterns)]
        HumanoidRootPart.Velocity = randomPattern * 150
        
        Notify("Combat", "Advanced dodge!", 1)
        task.wait(0.3)
        
        HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    end
end

function CollectRaidRewards()
    Notify("Raid", "Collecting raid rewards...", 3)
    
    -- Collect hearts
    CollectLeviHearts()
    
    -- Look for treasure
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj.Name:find("Treasure") or obj.Name:find("Reward") then
            HumanoidRootPart.CFrame = CFrame.new(obj.Position)
            task.wait(1)
            
            if obj:FindFirstChild("Click") then
                fireclickdetector(obj.Click)
            end
            
            Notify("Raid", "Collected reward!", 2)
            task.wait(1)
        end
    end
    
    -- Update statistics
    Statistics.BossesKilled = Statistics.BossesKilled + 1
    Statistics.ChestsOpened = Statistics.ChestsOpened + 1
    
    Notify("Raid", "Raid completed successfully!", 5)
end

-- UI Enhancement Functions
function UpdatePlayerStatsDisplay()
    coroutine.wrap(function()
        while true do
            -- Update player info
            local playerLevel = GetPlayerLevel()
            local playerBeli = GetPlayerBeli()
            
            -- Update UI labels if they exist
            for _, tab in pairs(Window.Tabs) do
                for _, section in pairs(tab.Sections) do
                    for _, element in pairs(section.Elements) do
                        if element.Name == "PlayerLevel" then
                            element:SetText("Level: " .. playerLevel)
                        elseif element.Name == "PlayerBeli" then
                            element:SetText("Beli: $" .. playerBeli)
                        end
                    end
                end
            end
            
         task.wait(10) -- Update every 10 seconds
        end
    end)()
end

function CreateStatusPanel()
    local statusTab = Window:MakeTab({
        Name = "Status",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    statusTab:AddSection({
        Name = "Player Status"
    })
    
    statusTab:AddLabel("Name: " .. Player.Name)
    statusTab:AddLabel("Level: " .. GetPlayerLevel())
    statusTab:AddLabel("Beli: $" .. GetPlayerBeli())
    
    local healthLabel = statusTab:AddLabel("Health: 100%")
    local positionLabel = statusTab:AddLabel("Position: 0, 0, 0")
    local islandLabel = statusTab:AddLabel("Island: None")
    local boatLabel = statusTab:AddLabel("Boat: None")
    
    statusTab:AddSection({
        Name = "Active Features"
    })
    
    local activeFeaturesLabel = statusTab:AddLabel("Active: None")
    
    -- Update status in real-time
    coroutine.wrap(function()
        while true do
            -- Update health
            if Humanoid then
                local healthPercent = math.floor((Humanoid.Health / Humanoid.MaxHealth) * 100)
                healthLabel:SetText("Health: " .. healthPercent .. "%")
            end
            
            -- Update position
            if HumanoidRootPart then
                local pos = HumanoidRootPart.Position
                positionLabel:SetText(string.format("Position: %.0f, %.0f, %.0f", pos.X, pos.Y, pos.Z))
            end
            
            -- Update island status
            local onIsland, islandName = IsPlayerInIsland()
            islandLabel:SetText("Island: " .. (islandName or "None"))
            
            -- Update boat status
            boatLabel:SetText("Boat: " .. (CurrentBoat and "Active" or "None"))
            
            -- Update active features
            local activeFeatures = {}
            if Settings.AutoFarm then table.insert(activeFeatures, "Auto Farm") end
            if Settings.AutoLevi then table.insert(activeFeatures, "Auto Levi") end
            if Settings.AutoBoat then table.insert(activeFeatures, "Auto Boat") end
            if Settings.AutoTikiIsland then table.insert(activeFeatures, "Tiki Island") end
            if Settings.AutoHydraIsland then table.insert(activeFeatures, "Hydra Island") end
            if Settings.AutoLeviRaid then table.insert(activeFeatures, "Leviathan Raid") end
            
            activeFeaturesLabel:SetText("Active: " .. (next(activeFeatures) and table.concat(activeFeatures, ", ") or "None"))
            
            task.wait(1)
        end
    end)()
    
    statusTab:AddSection({
        Name = "Quick Actions"
    })
    
    statusTab:AddButton({
        Name = "Refresh Status",
        Callback = function()
            -- Status updates automatically
        end
    })
    
    statusTab:AddButton({
        Name = "Force Save Settings",
        Callback = function()
            SaveSettings()
            Notify("Status", "Settings saved", 3)
        end
    })
end

-- Advanced Teleport System
local SavedLocations = {
    ["Home Base"] = Vector3.new(-1258, 18, 398),
    ["Fruit Dealer"] = Vector3.new(-604, 25, -475),
    ["Sword Dealer"] = Vector3.new(-1258, 18, 398),
    ["Boat Spawn"] = Vector3.new(57654, 4, 2515)
}

function CreateTeleportSystem()
    local teleportTab = Window:MakeTab({
        Name = "Teleport System",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    teleportTab:AddSection({
        Name = "Saved Locations"
    })
    
    -- Display saved locations
    for locationName, position in pairs(SavedLocations) do
        teleportTab:AddButton({
            Name = locationName,
            Callback = function()
                TeleportToLocation(position, locationName)
            end
        })
    end
    
    teleportTab:AddSection({
        Name = "Custom Location"
    })
    
    teleportTab:AddTextbox({
        Name = "Save Location Name",
        Default = "",
        TextDisappear = true,
        Callback = function(Value)
            if Value ~= "" then
                SaveCurrentLocation(Value)
            end
        end
    })
    
    teleportTab:AddButton({
        Name = "Save Current Position",
        Callback = function()
            SaveCurrentPosition()
        end
    })
    
    teleportTab:AddSection({
        Name = "Coordinate Teleport"
    })
    
    local xInput = teleportTab:AddTextbox({
        Name = "X Coordinate",
        Default = "0",
        TextDisappear = false,
        Callback = function(Value) end
    })
    
    local yInput = teleportTab:AddTextbox({
        Name = "Y Coordinate",
        Default = "0", 
        TextDisappear = false,
        Callback = function(Value) end
    })
    
    local zInput = teleportTab:AddTextbox({
        Name = "Z Coordinate",
        Default = "0",
        TextDisappear = false,
        Callback = function(Value) end
    })
    
    teleportTab:AddButton({
        Name = "Teleport to Coordinates",
        Callback = function()
            local x = tonumber(xInput.Value) or 0
            local y = tonumber(yInput.Value) or 0
            local z = tonumber(zInput.Value) or 0
            
            TeleportToCoordinates(x, y, z)
        end
    })
    
    teleportTab:AddButton({
        Name = "Copy Current Coordinates",
        Callback = function()
            CopyCurrentCoordinates()
        end
    })
    
    teleportTab:AddSection({
        Name = "Location Management"
    })
    
    teleportTab:AddButton({
        Name = "View All Saved Locations",
        Callback = function()
            DisplaySavedLocations()
        end
    })
    
    teleportTab:AddButton({
        Name = "Clear Saved Locations",
        Callback = function()
            ClearSavedLocations()
        end
    })
end

function TeleportToLocation(position, locationName)
    if not position then
        Notify("Teleport", "Invalid position", 3)
        return
    end
    
    HumanoidRootPart.CFrame = CFrame.new(position)
    Notify("Teleport", "Teleported to " .. (locationName or "location"), 3)
end

function TeleportToCoordinates(x, y, z)
    local targetPosition = Vector3.new(x, y, z)
    HumanoidRootPart.CFrame = CFrame.new(targetPosition)
    Notify("Teleport", string.format("Teleported to %.0f, %.0f, %.0f", x, y, z), 3)
end

function SaveCurrentPosition()
    local currentPosition = HumanoidRootPart.Position
    local locationName = "Saved Location " .. os.date("%H:%M:%S")
    
    SavedLocations[locationName] = currentPosition
    SaveTeleportData()
    
    Notify("Teleport", "Location saved: " .. locationName, 3)
end

function SaveCurrentLocation(name)
    local currentPosition = HumanoidRootPart.Position
    SavedLocations[name] = currentPosition
    SaveTeleportData()
    
    Notify("Teleport", "Location saved as: " .. name, 3)
end

function CopyCurrentCoordinates()
    local pos = HumanoidRootPart.Position
    local coordinates = string.format("%.0f, %.0f, %.0f", pos.X, pos.Y, pos.Z)
    
    setclipboard(coordinates)
    Notify("Teleport", "Coordinates copied: " .. coordinates, 3)
end

function SaveTeleportData()
    local success, errorMsg = pcall(function()
        local data = HttpService:JSONEncode(SavedLocations)
        writefile("AstraHub_TeleportData.json", data)
    end)
    
    if not success then
        Notify("Teleport", "Failed to save locations: " .. errorMsg, 3)
    end
end

function LoadTeleportData()
    local success, errorMsg = pcall(function()
        if isfile("AstraHub_TeleportData.json") then
            local data = readfile("AstraHub_TeleportData.json")
            local loadedData = HttpService:JSONDecode(data)
            
            for name, position in pairs(loadedData) do
                SavedLocations[name] = Vector3.new(position.X, position.Y, position.Z)
            end
        end
    end)
    
    if not success then
        Notify("Teleport", "Failed to load locations: " .. errorMsg, 3)
    end
end

function DisplaySavedLocations()
    local locationsText = "Saved Locations:\n"
    
    for name, position in pairs(SavedLocations) do
        locationsText = locationsText .. string.format("\n%s: %.0f, %.0f, %.0f", 
            name, position.X, position.Y, position.Z)
    end
    
    Notify("Teleport", locationsText, 10)
end

function ClearSavedLocations()
    SavedLocations = {
        ["Home Base"] = Vector3.new(-1258, 18, 398),
        ["Fruit Dealer"] = Vector3.new(-604, 25, -475),
        ["Sword Dealer"] = Vector3.new(-1258, 18, 398),
        ["Boat Spawn"] = Vector3.new(57654, 4, 2515)
    }
    
    SaveTeleportData()
    Notify("Teleport", "Saved locations cleared", 3)
end

-- Advanced Mob Detection System
function ScanAreaForMobs(center, radius)
    local mobsInArea = {}
    
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            local distance = (center - mob.HumanoidRootPart.Position).Magnitude
            if distance <= radius then
                table.insert(mobsInArea, {
                    Mob = mob,
                    Distance = distance,
                    Level = mob:GetAttribute("Level") or 0,
                    Health = mob.Humanoid.Health,
                    MaxHealth = mob.Humanoid.MaxHealth
                })
            end
        end
    end
    
    return mobsInArea
end

function GetMobDensity(center, radius)
    local mobs = ScanAreaForMobs(center, radius)
    local density = #mobs
    
    -- Calculate density per 1000 studs^2
    local area = math.pi * radius * radius
    local densityPerArea = (density / area) * 1000
    
    return {
        Count = density,
        Density = densityPerArea,
        Mobs = mobs
    }
end

function FindOptimalFarmingSpot()
    local playerPos = HumanoidRootPart.Position
    local searchRadius = 500
    local gridSize = 100
    local bestSpot = playerPos
    local bestDensity = 0
    
    -- Search in a grid pattern
    for x = -searchRadius, searchRadius, gridSize do
        for z = -searchRadius, searchRadius, gridSize do
            local checkPos = playerPos + Vector3.new(x, 0, z)
            local densityInfo = GetMobDensity(checkPos, 100)
            
            if densityInfo.Density > bestDensity then
                bestDensity = densityInfo.Density
                bestSpot = checkPos
            end
        end
    end
    
    return bestSpot, bestDensity
end

function AutoFindFarmingSpot()
    Notify("Auto Farm", "Searching for optimal farming spot...", 3)
    
    local optimalSpot, density = FindOptimalFarmingSpot()
    
    if density > 0 then
        -- Teleport to optimal spot
        HumanoidRootPart.CFrame = CFrame.new(optimalSpot)
        Notify("Auto Farm", "Found farming spot with density: " .. string.format("%.2f", density), 3)
        return optimalSpot
    else
        Notify("Auto Farm", "No good farming spots found nearby", 3)
        return nil
    end
end

-- Smart Resource Management
function CheckResourceNeeds()
    local needs = {
        HealthPotions = false,
        EnergyPotions = false,
        BoatRepair = false,
        WeaponRepair = false
    }
    
    -- Check health
    if Humanoid.Health < (Humanoid.MaxHealth * 0.5) then
        needs.HealthPotions = true
    end
    
    -- Check boat health
    if CurrentBoat and GetBoatHealth() < 50 then
        needs.BoatRepair = true
    end
    
    -- Check weapon durability (if applicable)
    local equippedWeapon = GetEquippedWeapon()
    if equippedWeapon and equippedWeapon:GetAttribute("Durability") then
        local durability = equippedWeapon:GetAttribute("Durability")
        if durability < 30 then
            needs.WeaponRepair = true
        end
    end
    
    return needs
end

function AutoManageResources()
    coroutine.wrap(function()
        while Settings.AutoResourceManagement do
            local needs = CheckResourceNeeds()
            
            if needs.HealthPotions then
                UseHealthPotion()
            end
            
            if needs.BoatRepair then
                RepairBoat()
            end
            
            if needs.WeaponRepair then
                RepairWeapon()
            end
            
            task.wait(30) -- Check every 30 seconds
        end
    end)()
end

function UseHealthPotion()
    -- Look for health potion in inventory
    local backpack = Player:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:find("Potion") and item.Name:find("Health") then
                -- Use potion
                Humanoid:EquipTool(item)
                task.wait(0.5)
                
                -- Simulate use
                VirtualInputManager:SendKeyEvent(true, "E", false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, "E", false, game)
                
                Notify("Resources", "Used health potion", 3)
                return true
            end
        end
    end
    
    return false
end

function GetEquippedWeapon()
    if Character then
        for _, item in pairs(Character:GetChildren()) do
            if item:IsA("Tool") and (item.Name:find("Sword") or item.Name:find("Fruit")) then
                return item
            end
        end
    end
    return nil
end

function RepairWeapon()
    local weapon = GetEquippedWeapon()
    if not weapon then return false end
    
    -- Look for repair station
    for _, station in pairs(Workspace:GetDescendants()) do
        if station.Name:find("Repair") and station.Name:find("Station") then
            -- Teleport to station
            local originalPos = HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(station.Position)
            task.wait(2)
            
            -- Attempt repair
            if station:FindFirstChild("Click") then
                fireclickdetector(station.Click)
                task.wait(1)
                
                -- Return to original position
                HumanoidRootPart.CFrame = CFrame.new(originalPos)
                
                Notify("Resources", "Weapon repaired", 3)
                return true
            end
        end
    end
    
    return false
end

-- Advanced Combat Analytics
local CombatStats = {
    TotalDamageDealt = 0,
    TotalDamageTaken = 0,
    HighestDamageHit = 0,
    AverageDamagePerHit = 0,
    HitAccuracy = 0,
    DodgeSuccessRate = 0,
    ComboChains = {},
    SkillUsage = {}
}

function TrackCombatStats()
    local damageDealt = 0
    local hits = 0
    local misses = 0
    local dodges = 0
    local successfulDodges = 0
    
    -- Damage dealt tracking
    local function onDamageDealt(target, amount)
        if amount > 0 then
            damageDealt = damageDealt + amount
            hits = hits + 1
            
            CombatStats.TotalDamageDealt = CombatStats.TotalDamageDealt + amount
            
            if amount > CombatStats.HighestDamageHit then
                CombatStats.HighestDamageHit = amount
            end
            
            -- Update average
            CombatStats.AverageDamagePerHit = CombatStats.TotalDamageDealt / hits
        else
            misses = misses + 1
        end
        
        -- Update accuracy
        CombatStats.HitAccuracy = (hits / (hits + misses)) * 100
    end
    
    -- Damage taken tracking
    local function onDamageTaken(amount)
        if amount > 0 then
            CombatStats.TotalDamageTaken = CombatStats.TotalDamageTaken + amount
        end
    end
    
    -- Dodge tracking
    local function onDodgeAttempt(success)
        dodges = dodges + 1
        if success then
            successfulDodges = successfulDodges + 1
        end
        
        CombatStats.DodgeSuccessRate = (successfulDodges / dodges) * 100
    end
    
    -- Skill usage tracking
    local function onSkillUsed(skillName)
        if not CombatStats.SkillUsage[skillName] then
            CombatStats.SkillUsage[skillName] = 0
        end
        CombatStats.SkillUsage[skillName] = CombatStats.SkillUsage[skillName] + 1
    end
    
    -- Combo chain tracking
    local currentCombo = 0
    local lastAttackTime = 0
    local comboThreshold = 1 -- seconds
    
    local function onAttack()
        local currentTime = tick()
        
        if currentTime - lastAttackTime <= comboThreshold then
            currentCombo = currentCombo + 1
        else
            if currentCombo > 0 then
                table.insert(CombatStats.ComboChains, currentCombo)
            end
            currentCombo = 1
        end
        
        lastAttackTime = currentTime
    end
    
    return {
        OnDamageDealt = onDamageDealt,
        OnDamageTaken = onDamageTaken,
        OnDodgeAttempt = onDodgeAttempt,
        OnSkillUsed = onSkillUsed,
        OnAttack = onAttack
    }
end

function DisplayCombatAnalytics()
    local analyticsTab = Window:MakeTab({
        Name = "Combat Analytics",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    analyticsTab:AddSection({
        Name = "Damage Statistics"
    })
    
    analyticsTab:AddLabel("Total Damage Dealt: " .. CombatStats.TotalDamageDealt)
    analyticsTab:AddLabel("Total Damage Taken: " .. CombatStats.TotalDamageTaken)
    analyticsTab:AddLabel("Highest Damage Hit: " .. CombatStats.HighestDamageHit)
    analyticsTab:AddLabel("Average Damage/Hit: " .. string.format("%.1f", CombatStats.AverageDamagePerHit))
    
    analyticsTab:AddSection({
        Name = "Performance Metrics"
    })
    
    analyticsTab:AddLabel("Hit Accuracy: " .. string.format("%.1f%%", CombatStats.HitAccuracy))
    analyticsTab:AddLabel("Dodge Success: " .. string.format("%.1f%%", CombatStats.DodgeSuccessRate))
    
    -- Calculate average combo
    local totalCombos = 0
    local maxCombo = 0
    for _, combo in pairs(CombatStats.ComboChains) do
        totalCombos = totalCombos + combo
        if combo > maxCombo then
            maxCombo = combo
        end
    end
    
    local avgCombo = #CombatStats.ComboChains > 0 and (totalCombos / #CombatStats.ComboChains) or 0
    analyticsTab:AddLabel("Average Combo: " .. string.format("%.1f", avgCombo))
    analyticsTab:AddLabel("Max Combo: " .. maxCombo)
    
    analyticsTab:AddSection({
        Name = "Skill Usage"
    })
    
    for skillName, count in pairs(CombatStats.SkillUsage) do
        analyticsTab:AddLabel(skillName .. ": " .. count .. " uses")
    end
    
    analyticsTab:AddSection({
        Name = "Analytics Control"
    })
    
    analyticsTab:AddButton({
        Name = "Refresh Analytics",
        Callback = function()
            DisplayCombatAnalytics()
        end
    })
    
    analyticsTab:AddButton({
        Name = "Reset Analytics",
        Callback = function()
            CombatStats = {
                TotalDamageDealt = 0,
                TotalDamageTaken = 0,
                HighestDamageHit = 0,
                AverageDamagePerHit = 0,
                HitAccuracy = 0,
                DodgeSuccessRate = 0,
                ComboChains = {},
                SkillUsage = {}
            }
            DisplayCombatAnalytics()
        end
    })
    
    analyticsTab:AddButton({
        Name = "Export Analytics",
        Callback = function()
            ExportCombatAnalytics()
        end
    })
end

function ExportCombatAnalytics()
    local exportData = {
        Timestamp = os.date("%Y-%m-%d %H:%M:%S"),
        Player = Player.Name,
        Level = GetPlayerLevel(),
        Statistics = CombatStats
    }
    
    local success, errorMsg = pcall(function()
        local jsonData = HttpService:JSONEncode(exportData)
        writefile("CombatAnalytics_" .. os.date("%Y%m%d_%H%M%S") .. ".json", jsonData)
    end)
    
    if success then
        Notify("Analytics", "Combat analytics exported successfully", 3)
    else
        Notify("Analytics", "Export failed: " .. errorMsg, 3)
    end
end

-- Auto Configuration System
local PresetConfigs = {
    ["Beginner Farm"] = {
        AutoFarm = true,
        AutoAttack = true,
        FarmRange = 200,
        MobPriority = "Lowest Level",
        AutoLevi = false,
        WalkSpeed = 30,
        JumpPower = 60
    },
    
    ["Island Explorer"] = {
        AutoBoat = true,
        AutoSpawnBoat = true,
        BoatSpeed = 120,
        AutoTikiIsland = true,
        IslandFarmMode = "Mobs",
        CollectTikiTotems = true,
        AutoCollectChests = true
    },
    
    ["Levi Specialist"] = {
        AutoLevi = true,
        LeviSkillDelay = 0.8,
        UseLeviDash = true,
        UseLeviSpin = true,
        UseLeviFlight = true,
        AutoLeviRaid = true,
        AutoCollectLeviHearts = true,
        CombatMode = "Aggressive"
    },
    
    ["Boss Hunter"] = {
        AutoFarm = true,
        MobPriority = "Boss Priority",
        FarmOnlySelected = false,
        AutoDodge = true,
        AutoBlock = true,
        UseM1Combo = true,
        UseSkillsCombo = true,
        RetreatHealth = 20,
        CombatMode = "Balanced"
    },
    
    ["Resource Collector"] = {
        AutoCollectChests = true,
        AutoCollectFruits = true,
        AutoSell = true,
        ESPEnabled = true,
        ESPChests = true,
        ESPFruits = true,
        WalkSpeed = 50,
        JumpPower = 80
    },
    
    ["Speed Run"] = {
        WalkSpeed = 100,
        JumpPower = 120,
        NoClip = false,
        Fly = true,
        AutoFarm = true,
        AutoAttack = true,
        FarmRange = 300,
        CombatMode = "Aggressive"
    }
}

function CreatePresetSystem()
    local presetTab = Window:MakeTab({
        Name = "Preset Configs",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    presetTab:AddSection({
        Name = "Quick Presets"
    })
    
    for presetName, presetConfig in pairs(PresetConfigs) do
        presetTab:AddButton({
            Name = presetName,
            Callback = function()
                LoadPreset(presetName)
            end
        })
    end
    
    presetTab:AddSection({
        Name = "Preset Management"
    })
    
    presetTab:AddTextbox({
        Name = "Save Preset Name",
        Default = "",
        TextDisappear = true,
        Callback = function(Value)
            if Value ~= "" then
                SaveCurrentAsPreset(Value)
            end
        end
    })
    
    presetTab:AddButton({
        Name = "Save Current Settings as Preset",
        Callback = function()
            SaveCurrentSettingsAsPreset()
        end
    })
    
    presetTab:AddButton({
        Name = "Delete Preset",
        Callback = function()
            DeletePresetUI()
        end
    })
    
    presetTab:AddSection({
        Name = "Custom Preset"
    })
    
    presetTab:AddButton({
        Name = "Create Custom Preset",
        Callback = function()
            CreateCustomPresetUI()
        end
    })
end

function LoadPreset(presetName)
    local presetConfig = PresetConfigs[presetName]
    
    if not presetConfig then
        Notify("Preset", "Preset not found: " .. presetName, 3)
        return
    end
    
    -- Apply preset settings
    for settingName, value in pairs(presetConfig) do
        Settings[settingName] = value
        
        -- Update UI toggles if they exist
        UpdateUISetting(settingName, value)
    end
    
    -- Apply immediate effects
    if Settings.WalkSpeed and Humanoid then
        Humanoid.WalkSpeed = Settings.WalkSpeed
    end
    
    if Settings.JumpPower and Humanoid then
        Humanoid.JumpPower = Settings.JumpPower
    end
    
    Notify("Preset", "Loaded preset: " .. presetName, 3)
    SaveSettings()
end

function UpdateUISetting(settingName, value)
    -- This function would update UI elements to reflect new settings
    -- Implementation depends on OrionLib's API
end

function SaveCurrentAsPreset(presetName)
    if PresetConfigs[presetName] then
        Notify("Preset", "Preset already exists: " .. presetName, 3)
        return
    end
    
    -- Create preset from current settings
    local newPreset = {}
    
    for key, value in pairs(Settings) do
        newPreset[key] = value
    end
    
    PresetConfigs[presetName] = newPreset
    SavePresets()
    
    Notify("Preset", "Preset saved: " .. presetName, 3)
end

function SaveCurrentSettingsAsPreset()
    local presetName = "Custom_" .. os.date("%Y%m%d_%H%M%S")
    SaveCurrentAsPreset(presetName)
end

function SavePresets()
    local success, errorMsg = pcall(function()
        local data = HttpService:JSONEncode(PresetConfigs)
        writefile("AstraHub_Presets.json", data)
    end)
    
    if not success then
        Notify("Preset", "Failed to save presets: " .. errorMsg, 3)
    end
end

function LoadPresets()
    local success, errorMsg = pcall(function()
        if isfile("AstraHub_Presets.json") then
            local data = readfile("AstraHub_Presets.json")
            local loadedPresets = HttpService:JSONDecode(data)
            
            for name, config in pairs(loadedPresets) do
                PresetConfigs[name] = config
            end
        end
    end)
    
    if not success then
        Notify("Preset", "Failed to load presets: " .. errorMsg, 3)
    end
end

function DeletePresetUI()
    -- Create delete preset interface
    local deleteWindow = OrionLib:MakeWindow({
        Name = "Delete Preset",
        HidePremium = false,
        SaveConfig = false,
        ConfigFolder = "AstraHubPresets"
    })
    
    local deleteTab = deleteWindow:MakeTab({
        Name = "Delete",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    deleteTab:AddSection({
        Name = "Select Preset to Delete"
    })
    
    for presetName, _ in pairs(PresetConfigs) do
        deleteTab:AddButton({
            Name = "Delete: " .. presetName,
            Callback = function()
                DeletePreset(presetName)
                deleteWindow:Destroy()
            end
        })
    end
    
    deleteTab:AddSection({
        Name = "Cancel"
    })
    
    deleteTab:AddButton({
        Name = "Cancel",
        Callback = function()
            deleteWindow:Destroy()
        end
    })
end

function DeletePreset(presetName)
    if PresetConfigs[presetName] then
        PresetConfigs[presetName] = nil
        SavePresets()
        Notify("Preset", "Deleted preset: " .. presetName, 3)
    else
        Notify("Preset", "Preset not found: " .. presetName, 3)
    end
end

function CreateCustomPresetUI()
    local customWindow = OrionLib:MakeWindow({
        Name = "Create Custom Preset",
        HidePremium = false,
        SaveConfig = false,
        ConfigFolder = "AstraHubCustomPreset"
    })
    
    local customTab = customWindow:MakeTab({
        Name = "Custom Preset",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    customTab:AddSection({
        Name = "Preset Name"
    })
    
    local presetNameInput = customTab:AddTextbox({
        Name = "Preset Name",
        Default = "MyPreset",
        TextDisappear = false,
        Callback = function(Value) end
    })
    
    customTab:AddSection({
        Name = "Auto Farm Settings"
    })
    
    local autoFarmToggle = customTab:AddToggle({
        Name = "Auto Farm",
        Default = Settings.AutoFarm,
        Callback = function(Value) end
    })
    
    local farmRangeSlider = customTab:AddSlider({
        Name = "Farm Range",
        Min = 10,
        Max = 1000,
        Default = Settings.FarmRange,
        Color = Colors.Accent,
        Increment = 10,
        ValueName = "studs",
        Callback = function(Value) end
    })
    
    customTab:AddSection({
        Name = "Levi Settings"
    })
    
    local autoLeviToggle = customTab:AddToggle({
        Name = "Auto Levi",
        Default = Settings.AutoLevi,
        Callback = function(Value) end
    })
    
    customTab:AddSection({
        Name = "Create Preset"
    })
    
    customTab:AddButton({
        Name = "Create Preset",
        Callback = function()
            local presetName = presetNameInput.Value
            
            if presetName == "" then
                Notify("Preset", "Please enter a preset name", 3)
                return
            end
            
            local customPreset = {
                AutoFarm = autoFarmToggle.Value,
                FarmRange = farmRangeSlider.Value,
                AutoLevi = autoLeviToggle.Value,
                -- Add more settings as needed
            }
            
            PresetConfigs[presetName] = customPreset
            SavePresets()
            
            customWindow:Destroy()
            Notify("Preset", "Custom preset created: " .. presetName, 3)
        end
    })
    
    customTab:AddButton({
        Name = "Cancel",
        Callback = function()
            customWindow:Destroy()
        end
    })
end

-- Macro Recording System
local MacroRecorder = {
    IsRecording = false,
    IsPlaying = false,
    CurrentMacro = {},
    RecordStartTime = 0,
    Macros = {}
}

function StartMacroRecording(macroName)
    if MacroRecorder.IsRecording then
        Notify("Macro", "Already recording a macro", 3)
        return
    end
    
    MacroRecorder.IsRecording = true
    MacroRecorder.CurrentMacro = {
        Name = macroName,
        Actions = {},
        StartTime = tick()
    }
    
    Notify("Macro", "Recording macro: " .. macroName, 3)
    
    -- Record player actions
    RecordPlayerActions()
end

function StopMacroRecording()
    if not MacroRecorder.IsRecording then
        Notify("Macro", "Not recording any macro", 3)
        return
    end
    
    MacroRecorder.IsRecording = false
    MacroRecorder.Macros[MacroRecorder.CurrentMacro.Name] = MacroRecorder.CurrentMacro
    
    SaveMacros()
    Notify("Macro", "Stopped recording: " .. MacroRecorder.CurrentMacro.Name, 3)
end

function RecordPlayerActions()
    coroutine.wrap(function()
        while MacroRecorder.IsRecording do
            -- Record movement
            local velocity = HumanoidRootPart.Velocity
            if velocity.Magnitude > 0 then
                table.insert(MacroRecorder.CurrentMacro.Actions, {
                    Type = "Movement",
                    Time = tick() - MacroRecorder.CurrentMacro.StartTime,
                    Velocity = velocity
                })
            end
            
            -- Record attacks (would need to detect attack events)
            
            task.wait(0.1)
        end
    end)()
end

function PlayMacro(macroName)
    local macro = MacroRecorder.Macros[macroName]
    
    if not macro then
        Notify("Macro", "Macro not found: " .. macroName, 3)
        return
    end
    
    if MacroRecorder.IsPlaying then
        Notify("Macro", "Already playing a macro", 3)
        return
    end
    
    MacroRecorder.IsPlaying = true
    Notify("Macro", "Playing macro: " .. macroName, 3)
    
    coroutine.wrap(function()
        local startTime = tick()
        
        for _, action in pairs(macro.Actions) do
            if not MacroRecorder.IsPlaying then break end
            
            -- Wait for the correct time
            local elapsed = tick() - startTime
            local waitTime = action.Time - elapsed
            
            if waitTime > 0 then
                task.wait(waitTime)
            end
            
            -- Execute action
            if action.Type == "Movement" then
                HumanoidRootPart.Velocity = action.Velocity
            elseif action.Type == "Attack" then
                -- Execute attack
            end
        end
        
        MacroRecorder.IsPlaying = false
        Notify("Macro", "Finished playing: " .. macroName, 3)
    end)()
end

function SaveMacros()
    local success, errorMsg = pcall(function()
        local data = HttpService:JSONEncode(MacroRecorder.Macros)
        writefile("AstraHub_Macros.json", data)
    end)
    
    if not success then
        Notify("Macro", "Failed to save macros: " .. errorMsg, 3)
    end
end

function LoadMacros()
    local success, errorMsg = pcall(function()
        if isfile("AstraHub_Macros.json") then
            local data = readfile("AstraHub_Macros.json")
            MacroRecorder.Macros = HttpService:JSONDecode(data)
        end
    end)
    
    if not success then
        Notify("Macro", "Failed to load macros: " .. errorMsg, 3)
    end
end

-- Initialize additional systems
function InitializeAdditionalSystems()
    -- Load teleport data
    LoadTeleportData()
    
    -- Load presets
    LoadPresets()
    
    -- Load macros
    LoadMacros()
    
    -- Create additional UI tabs
    CreateStatusPanel()
    CreateTeleportSystem()
    CreatePresetSystem()
    
    -- Start resource management
    if Settings.AutoResourceManagement then
        AutoManageResources()
    end
    
    -- Start auto configuration
    if Settings.AutoConfiguration then
        ApplyAutoConfiguration()
    end
    
    Notify("System", "Additional systems initialized", 3)
end

-- Auto Configuration System
function ApplyAutoConfiguration()
    local playerLevel = GetPlayerLevel()
    
    if playerLevel < 100 then
        LoadPreset("Beginner Farm")
        Notify("Auto Config", "Applied Beginner Farm preset", 3)
    elseif playerLevel < 500 then
        LoadPreset("Resource Collector")
        Notify("Auto Config", "Applied Resource Collector preset", 3)
    elseif playerLevel < 1000 then
        LoadPreset("Boss Hunter")
        Notify("Auto Config", "Applied Boss Hunter preset", 3)
    else
        LoadPreset("Levi Specialist")
        Notify("Auto Config", "Applied Levi Specialist preset", 3)
    end
end

-- Advanced Player Protection System
local ProtectionSystem = {
    AntiStuck = true,
    AntiFall = true,
    AntiTeleport = true,
    LastSafePosition = Vector3.new(0, 0, 0),
    LastPositionUpdate = tick(),
    StuckCheckInterval = 5,
    FallThreshold = -100
}

function InitializeProtectionSystem()
    ProtectionSystem.LastSafePosition = HumanoidRootPart.Position
    
    -- Position tracking
    local positionTracker = RunService.Heartbeat:Connect(function()
        ProtectionSystem.LastSafePosition = HumanoidRootPart.Position
        ProtectionSystem.LastPositionUpdate = tick()
    end)
    
    -- Anti-stuck system
    if ProtectionSystem.AntiStuck then
        StartAntiStuckSystem()
    end
    
    -- Anti-fall system
    if ProtectionSystem.AntiFall then
        StartAntiFallSystem()
    end
    
    -- Anti-teleport protection
    if ProtectionSystem.AntiTeleport then
        StartAntiTeleportProtection()
    end
    
    table.insert(ESPObjects, positionTracker)
end

function StartAntiStuckSystem()
    coroutine.wrap(function()
        local lastPosition = HumanoidRootPart.Position
        local stuckStartTime = tick()
        local stuckThreshold = 10 -- seconds
        
        while ProtectionSystem.AntiStuck do
            local currentPosition = HumanoidRootPart.Position
            local distanceMoved = (currentPosition - lastPosition).Magnitude
            
            if distanceMoved < 5 then -- Player hasn't moved much
                if tick() - stuckStartTime > stuckThreshold then
                    Notify("Protection", "Player may be stuck! Attempting recovery...", 3)
                    RecoverFromStuck()
                    stuckStartTime = tick()
                end
            else
                stuckStartTime = tick()
                lastPosition = currentPosition
            end
            
            task.wait(ProtectionSystem.StuckCheckInterval)
        end
    end)()
end

function RecoverFromStuck()
    -- Try different recovery methods
    local recoveryMethods = {
        function()
            -- Jump
            Humanoid.Jump = true
            task.wait(0.5)
        end,
        function()
            -- Teleport slightly
            local offset = Vector3.new(math.random(-10, 10), 5, math.random(-10, 10))
            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + offset
        end,
        function()
            -- Use Levi dash
            UseLeviSkill("Levi Dash")
        end
    }
    
    for _, method in pairs(recoveryMethods) do
        local success = pcall(method)
        if success then
            Notify("Protection", "Recovery attempt successful", 3)
            return true
        end
    end
    
    -- Last resort: teleport to safe position
    HumanoidRootPart.CFrame = CFrame.new(ProtectionSystem.LastSafePosition)
    Notify("Protection", "Teleported to last safe position", 3)
    
    return false
end

function StartAntiFallSystem()
    local fallProtection = RunService.Heartbeat:Connect(function()
        if not ProtectionSystem.AntiFall then return end
        
        local playerY = HumanoidRootPart.Position.Y
        
        if playerY < ProtectionSystem.FallThreshold then
            Notify("Protection", "Player falling! Teleporting to safety...", 3)
            
            -- Save current velocity to prevent fall damage
            local originalVelocity = HumanoidRootPart.Velocity
            HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            
            -- Teleport to safe position
            HumanoidRootPart.CFrame = CFrame.new(ProtectionSystem.LastSafePosition)
            
            task.wait(0.5)
            
            -- Restore velocity (reduced)
            HumanoidRootPart.Velocity = originalVelocity * 0.5
        end
    end)
    
    table.insert(ESPObjects, fallProtection)
end

function StartAntiTeleportProtection()
    local teleportProtection = RunService.Heartbeat:Connect(function()
        if not ProtectionSystem.AntiTeleport then return end
        
        local currentPosition = HumanoidRootPart.Position
        local lastPosition = ProtectionSystem.LastSafePosition
        local distance = (currentPosition - lastPosition).Magnitude
        
        -- If teleported unusually far in one frame
        if distance > 500 and tick() - ProtectionSystem.LastPositionUpdate < 0.1 then
            Notify("Protection", "Unusual teleport detected! Safety check...", 3)
            
            -- Check if teleport was intended (by our script)
            local isIntendedTeleport = false
            
            -- You could add logic to check if teleport was from your script
            
            if not isIntendedTeleport then
                -- Revert to safe position
                HumanoidRootPart.CFrame = CFrame.new(lastPosition)
                Notify("Protection", "Reverted to safe position", 3)
            end
        end
    end)
    
    table.insert(ESPObjects, teleportProtection)
end

-- Advanced Boat Combat System
function EnableBoatCombat()
    if not CurrentBoat then
        Notify("Boat Combat", "No boat available", 3)
        return false
    end
    
    Settings.BoatCombatEnabled = true
    
    coroutine.wrap(function()
        while Settings.BoatCombatEnabled and CurrentBoat do
            -- Find sea enemies
            local seaTargets = GetSeaTargets()
            
            if #seaTargets > 0 then
                -- Engage closest target
                local target = seaTargets[1]
                EngageSeaTarget(target)
            else
                -- Patrol
                PatrolSeaArea()
            end
            
            task.wait(1)
        end
    end)()
    
    Notify("Boat Combat", "Boat combat enabled", 3)
    return true
end

function GetSeaTargets()
    local seaTargets = {}
    
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            -- Check if it's a sea enemy
            local mobName = mob.Name:lower()
            if mobName:find("shark") or mobName:find("sea") or mobName:find("leviathan") then
                table.insert(seaTargets, {
                    Mob = mob,
                    Distance = (CurrentBoat.Main.Position - mob.HumanoidRootPart.Position).Magnitude
                })
            end
        end
    end
    
    -- Sort by distance
    table.sort(seaTargets, function(a, b)
        return a.Distance < b.Distance
    end)
    
    return seaTargets
end

function EngageSeaTarget(targetInfo)
    local target = targetInfo.Mob
    local boatPos = CurrentBoat.Main.Position
    local targetPos = target.HumanoidRootPart.Position
    local distance = targetInfo.Distance
    
    -- Combat tactics
    if distance > 100 then
        -- Approach target
        local direction = (targetPos - boatPos).Unit
        CurrentBoat.Main.Velocity = direction * Settings.BoatSpeed
    elseif distance > 50 then
        -- Circle around target
        local angle = tick() * 2
        local radius = 60
        local offset = Vector3.new(
            math.cos(angle) * radius,
            0,
            math.sin(angle) * radius
        )
        
        local targetPosition = targetPos + offset
        local direction = (targetPosition - boatPos).Unit
        CurrentBoat.Main.Velocity = direction * (Settings.BoatSpeed * 0.7)
        
        -- Attack while circling
        UseBoatWeapons(target)
    else
        -- Too close, back away
        local direction = (boatPos - targetPos).Unit
        CurrentBoat.Main.Velocity = direction * Settings.BoatSpeed
    end
    
    -- Avoid collisions
    AvoidSeaObstacles()
end

function UseBoatWeapons(target)
    -- Simulate boat weapon attacks
    -- This would depend on the game's boat combat system
    
    -- Use Levi skills from boat
    if Settings.AutoLevi and target then
        local distance = (CurrentBoat.Main.Position - target.HumanoidRootPart.Position).Magnitude
        
        if distance < 80 then
            -- Use Levi skills that work from boat
            UseLeviSkill("Levi Vortex")
            task.wait(1)
            UseLeviSkill("Levi Tsunami")
        end
    end
end

function PatrolSeaArea()
    if not CurrentBoat then return end
    
    -- Create patrol pattern
    local patrolPoints = {
        CurrentBoat.Main.Position + Vector3.new(200, 0, 0),
        CurrentBoat.Main.Position + Vector3.new(0, 0, 200),
        CurrentBoat.Main.Position + Vector3.new(-200, 0, 0),
        CurrentBoat.Main.Position + Vector3.new(0, 0, -200)
    }
    
    local currentPatrolIndex = 1
    
    while Settings.BoatCombatEnabled and #GetSeaTargets() == 0 do
        local targetPoint = patrolPoints[currentPatrolIndex]
        local boatPos = CurrentBoat.Main.Position
        local distance = (boatPos - targetPoint).Magnitude
        
        if distance < 50 then
            -- Move to next patrol point
            currentPatrolIndex = currentPatrolIndex + 1
            if currentPatrolIndex > #patrolPoints then
                currentPatrolIndex = 1
            end
        else
            -- Move towards patrol point
            local direction = (targetPoint - boatPos).Unit
            CurrentBoat.Main.Velocity = direction * (Settings.BoatSpeed * 0.5)
        end
        
        task.wait(1)
    end
end

function AvoidSeaObstacles()
    if not CurrentBoat then return end
    
    local boatPos = CurrentBoat.Main.Position
    local avoidanceForce = Vector3.new(0, 0, 0)
    
    -- Check for obstacles
    for _, obstacle in pairs(Workspace:GetDescendants()) do
        if obstacle:IsA("BasePart") and obstacle.CanCollide then
            local obstaclePos = obstacle.Position
            local distance = (boatPos - obstaclePos).Magnitude
            
            if distance < 50 then
                -- Calculate avoidance direction
                local avoidDirection = (boatPos - obstaclePos).Unit
                avoidanceForce = avoidanceForce + (avoidDirection * (100 - distance))
            end
        end
    end
    
    -- Apply avoidance if needed
    if avoidanceForce.Magnitude > 0 then
        CurrentBoat.Main.Velocity = avoidanceForce.Unit * Settings.BoatSpeed
        task.wait(1)
    end
end

-- Advanced Farming Route System
local FarmingRoutes = {
    ["Starter Island Circuit"] = {
        Waypoints = {
            Vector3.new(-1258, 18, 398),
            Vector3.new(-1600, 37, 153),
            Vector3.new(-1076, 14, 1454),
            Vector3.new(-604, 25, -475)
        },
        MobTypes = {"Bandit", "Monkey", "Gorilla"},
        RecommendedLevel = 1
    },
    
    ["Desert Loop"] = {
        Waypoints = {
            Vector3.new(1089, 48, 4182),
            Vector3.new(1500, 48, 4500),
            Vector3.new(2000, 48, 4182),
            Vector3.new(1500, 48, 3800)
        },
        MobTypes = {"Desert Bandit", "Desert Warrior"},
        RecommendedLevel = 100
    },
    
    ["Frozen Path"] = {
        Waypoints = {
            Vector3.new(1191, 48, -1410),
            Vector3.new(1500, 48, -1000),
            Vector3.new(1800, 48, -1410),
            Vector3.new(1500, 48, -1800)
        },
        MobTypes = {"Ice Warrior", "Frozen Brute"},
        RecommendedLevel = 150
    }
}

function ExecuteFarmingRoute(routeName)
    local route = FarmingRoutes[routeName]
    
    if not route then
        Notify("Farming Route", "Route not found: " .. routeName, 3)
        return
    end
    
    Settings.CurrentFarmingRoute = routeName
    
    coroutine.wrap(function()
        Notify("Farming Route", "Starting route: " .. routeName, 3)
        
        local currentWaypoint = 1
        
        while Settings.CurrentFarmingRoute == routeName do
            -- Navigate to waypoint
            local waypoint = route.Waypoints[currentWaypoint]
            HumanoidRootPart.CFrame = CFrame.new(waypoint)
            
            Notify("Farming Route", "Waypoint " .. currentWaypoint .. "/" .. #route.Waypoints, 2)
            
            -- Farm at waypoint
            FarmAtWaypoint(route.MobTypes, 30) -- Farm for 30 seconds
            
            -- Move to next waypoint
            currentWaypoint = currentWaypoint + 1
            if currentWaypoint > #route.Waypoints then
                currentWaypoint = 1
            end
        end
        
        Notify("Farming Route", "Route stopped: " .. routeName, 3)
    end)()
end

function FarmAtWaypoint(mobTypes, duration)
    local startTime = tick()
    
    while tick() - startTime < duration and Settings.CurrentFarmingRoute do
        -- Find mobs of specified types
        local mobs = FindMobsByType(mobTypes, 100)
        
        if #mobs > 0 then
            -- Farm the mobs
            for _, mob in pairs(mobs) do
                if not Settings.CurrentFarmingRoute then break end
                FarmTarget(mob)
                task.wait(0.5)
            end
        else
            -- Wait for respawn or move slightly
            task.wait(2)
        end
    end
end

function FindMobsByType(mobTypes, radius)
    local foundMobs = {}
    local playerPos = HumanoidRootPart.Position
    
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            local distance = (playerPos - mob.HumanoidRootPart.Position).Magnitude
            
            if distance <= radius then
                for _, mobType in pairs(mobTypes) do
                    if mob.Name:find(mobType) then
                        table.insert(foundMobs, mob)
                        break
                    end
                end
            end
        end
    end
    
    return foundMobs
end

function CreateFarmingRouteSystem()
    local routeTab = Window:MakeTab({
        Name = "Farming Routes",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    routeTab:AddSection({
        Name = "Predefined Routes"
    })
    
    for routeName, routeData in pairs(FarmingRoutes) do
        routeTab:AddButton({
            Name = routeName .. " (Level " .. routeData.RecommendedLevel .. "+)",
            Callback = function()
                ExecuteFarmingRoute(routeName)
            end
        })
    end
    
    routeTab:AddSection({
        Name = "Route Control"
    })
    
    routeTab:AddToggle({
        Name = "Auto Switch Routes",
        Default = false,
        Callback = function(Value)
            Settings.AutoSwitchRoutes = Value
            if Value then
                StartAutoRouteSwitching()
            end
        end
    })
    
    routeTab:AddSlider({
        Name = "Route Duration (minutes)",
        Min = 1,
        Max = 60,
        Default = 10,
        Color = Colors.Accent,
        Increment = 1,
        ValueName = "minutes",
        Callback = function(Value)
            Settings.RouteDuration = Value * 60 -- Convert to seconds
        end
    })
    
    routeTab:AddSection({
        Name = "Custom Route"
    })
    
    routeTab:AddTextbox({
        Name = "New Route Name",
        Default = "",
        TextDisappear = true,
        Callback = function(Value)
            if Value ~= "" then
                StartRecordingCustomRoute(Value)
            end
        end
    })
    
    routeTab:AddButton({
        Name = "Create Custom Route",
        Callback = function()
            CreateCustomRouteUI()
        end
    })
end

function StartAutoRouteSwitching()
    coroutine.wrap(function()
        while Settings.AutoSwitchRoutes do
            local playerLevel = GetPlayerLevel()
            
            -- Select appropriate route based on level
            local selectedRoute = nil
            
            if playerLevel < 50 then
                selectedRoute = "Starter Island Circuit"
            elseif playerLevel < 150 then
                selectedRoute = "Desert Loop"
            else
                selectedRoute = "Frozen Path"
            end
            
            -- Execute route
            ExecuteFarmingRoute(selectedRoute)
            
            -- Run for configured duration
            task.wait(Settings.RouteDuration)
            
            -- Stop current route
            Settings.CurrentFarmingRoute = nil
        end
    end)()
end

function StartRecordingCustomRoute(routeName)
    Notify("Farming Route", "Recording new route: " .. routeName, 3)
    
    FarmingRoutes[routeName] = {
        Waypoints = {},
        MobTypes = {},
        RecommendedLevel = GetPlayerLevel()
    }
    
    local recording = true
    local recordStartTime = tick()
    
    -- Record waypoints as player moves
    local waypointInterval = 10 -- seconds
    local lastWaypointTime = tick()
    
    coroutine.wrap(function()
        while recording do
            local currentTime = tick()
            
            if currentTime - lastWaypointTime >= waypointInterval then
                -- Record waypoint
                table.insert(FarmingRoutes[routeName].Waypoints, HumanoidRootPart.Position)
                lastWaypointTime = currentTime
                
                Notify("Route Recording", "Waypoint recorded: " .. #FarmingRoutes[routeName].Waypoints, 2)
            end
            
            task.wait(1)
        end
    end)()
    
    -- Stop recording after 5 minutes or manually
    task.wait(300) -- 5 minutes
    
    recording = false
    SaveFarmingRoutes()
    
    Notify("Farming Route", "Route recording complete: " .. routeName, 3)
    Notify("Farming Route", "Recorded " .. #FarmingRoutes[routeName].Waypoints .. " waypoints", 3)
end

function SaveFarmingRoutes()
    local success, errorMsg = pcall(function()
        local data = HttpService:JSONEncode(FarmingRoutes)
        writefile("AstraHub_FarmingRoutes.json", data)
    end)
    
    if not success then
        Notify("Farming Routes", "Failed to save routes: " .. errorMsg, 3)
    end
end

function LoadFarmingRoutes()
    local success, errorMsg = pcall(function()
        if isfile("AstraHub_FarmingRoutes.json") then
            local data = readfile("AstraHub_FarmingRoutes.json")
            local loadedRoutes = HttpService:JSONDecode(data)
            
            for name, route in pairs(loadedRoutes) do
                FarmingRoutes[name] = route
            end
        end
    end)
    
    if not success then
        Notify("Farming Routes", "Failed to load routes: " .. errorMsg, 3)
    end
end

function CreateCustomRouteUI()
    local routeWindow = OrionLib:MakeWindow({
        Name = "Create Custom Route",
        HidePremium = false,
        SaveConfig = false,
        ConfigFolder = "AstraHubCustomRoute"
    })
    
    local routeTab = routeWindow:MakeTab({
        Name = "Custom Route",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    routeTab:AddSection({
        Name = "Route Configuration"
    })
    
    local routeNameInput = routeTab:AddTextbox({
        Name = "Route Name",
        Default = "MyCustomRoute",
        TextDisappear = false,
        Callback = function(Value) end
    })
    
    local mobTypesInput = routeTab:AddTextbox({
        Name = "Mob Types (comma separated)",
        Default = "Bandit,Monkey,Gorilla",
        TextDisappear = false,
        Callback = function(Value) end
    })
    
    routeTab:AddSection({
        Name = "Add Current Position"
    })
    
    local waypointsList = routeTab:AddLabel("Waypoints: 0")
    local currentWaypoints = {}
    
    routeTab:AddButton({
        Name = "Add Current Position as Waypoint",
        Callback = function()
            table.insert(currentWaypoints, HumanoidRootPart.Position)
            waypointsList:SetText("Waypoints: " .. #currentWaypoints)
        end
    })
    
    routeTab:AddButton({
        Name = "Clear Waypoints",
        Callback = function()
            currentWaypoints = {}
            waypointsList:SetText("Waypoints: 0")
        end
    })
    
    routeTab:AddSection({
        Name = "Save Route"
    })
    
    routeTab:AddButton({
        Name = "Save Custom Route",
        Callback = function()
            local routeName = routeNameInput.Value
            local mobTypes = {}
            
            for mobType in string.gmatch(mobTypesInput.Value, "[^,]+") do
                table.insert(mobTypes, mobType:trim())
            end
            
            if routeName == "" then
                Notify("Route", "Please enter a route name", 3)
                return
            end
            
            if #currentWaypoints == 0 then
                Notify("Route", "Please add at least one waypoint", 3)
                return
            end
            
            FarmingRoutes[routeName] = {
                Waypoints = currentWaypoints,
                MobTypes = mobTypes,
                RecommendedLevel = GetPlayerLevel()
            }
            
            SaveFarmingRoutes()
            routeWindow:Destroy()
            
            Notify("Route", "Custom route saved: " .. routeName, 3)
        end
    })
    
    routeTab:AddButton({
        Name = "Cancel",
        Callback = function()
            routeWindow:Destroy()
        end
    })
end

-- Advanced Skill Rotation Optimization
function OptimizeSkillRotation()
    local skillData = {
        ["Levi Dash"] = {Damage = 2500, Cooldown = 5, Range = 100, Type = "Movement"},
        ["Levi Spin"] = {Damage = 3500, Cooldown = 8, Range = 50, Type = "AoE"},
        ["Levi Flight"] = {Damage = 2000, Cooldown = 12, Range = 75, Type = "Movement"},
        ["Levi Vortex"] = {Damage = 5000, Cooldown = 15, Range = 80, Type = "AoE"},
        ["Levi Tsunami"] = {Damage = 10000, Cooldown = 30, Range = 150, Type = "Ultimate"}
    }
    
    -- Calculate Damage Per Second for each skill
    for skillName, data in pairs(skillData) do
        data.DPS = data.Damage / data.Cooldown
    end
    
    -- Create optimized rotation based on DPS
    local optimizedRotation = {}
    
    for skillName, data in pairs(skillData) do
        if Settings["Use" .. skillName:gsub(" ", "")] then
            table.insert(optimizedRotation, {
                Name = skillName,
                DPS = data.DPS,
                Damage = data.Damage,
                Cooldown = data.Cooldown
            })
        end
    end
    
    -- Sort by DPS (highest first)
    table.sort(optimizedRotation, function(a, b)
        return a.DPS > b.DPS
    end)
    
    return optimizedRotation
end

function ExecuteOptimizedRotation(target)
    local rotation = OptimizeSkillRotation()
    
    if #rotation == 0 then
        return
    end
    
    for _, skill in pairs(rotation) do
        if not Settings.AutoLevi then break end
        
        -- Check if skill is ready (simplified)
        UseLeviSkill(skill.Name)
        task.wait(skill.Cooldown * 0.8) -- Wait 80% of cooldown for next skill
    end
end

-- Experience and Level Tracking
local ExperienceTracker = {
    StartLevel = 0,
    StartTime = 0,
    LevelsGained = 0,
    ExperienceRate = 0,
    EstimatedTimeToNextLevel = 0
}

function StartExperienceTracking()
    ExperienceTracker.StartLevel = GetPlayerLevel()
    ExperienceTracker.StartTime = tick()
    
    coroutine.wrap(function()
        while true do
            local currentLevel = GetPlayerLevel()
            local timeElapsed = tick() - ExperienceTracker.StartTime
            
            ExperienceTracker.LevelsGained = currentLevel - ExperienceTracker.StartLevel
            
            if timeElapsed > 0 then
                ExperienceTracker.ExperienceRate = (ExperienceTracker.LevelsGained / timeElapsed) * 3600 -- Levels per hour
                
                if ExperienceTracker.ExperienceRate > 0 then
                    ExperienceTracker.EstimatedTimeToNextLevel = (1 / ExperienceTracker.ExperienceRate) * 3600 -- Seconds to next level
                end
            end
            
            task.wait(10) -- Update every 10 seconds
        end
    end)()
end

function DisplayExperienceStats()
    local expTab = Window:MakeTab({
        Name = "Experience",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    expTab:AddSection({
        Name = "Current Stats"
    })
    
    local levelLabel = expTab:AddLabel("Current Level: " .. GetPlayerLevel())
    local levelsGainedLabel = expTab:AddLabel("Levels Gained: " .. ExperienceTracker.LevelsGained)
    local expRateLabel = expTab:AddLabel("Levels/Hour: " .. string.format("%.2f", ExperienceTracker.ExperienceRate))
    
    local timeToNextLevel = "N/A"
    if ExperienceTracker.EstimatedTimeToNextLevel > 0 then
        local hours = math.floor(ExperienceTracker.EstimatedTimeToNextLevel / 3600)
        local minutes = math.floor((ExperienceTracker.EstimatedTimeToNextLevel % 3600) / 60)
        timeToNextLevel = string.format("%dh %dm", hours, minutes)
    end
    local timeLabel = expTab:AddLabel("Time to Next Level: " .. timeToNextLevel)
    
    expTab:AddSection({
        Name = "Session Tracking"
    })
    
    local sessionTime = 0
    local sessionTimer = expTab:AddLabel("Session Time: 00:00:00")
    
    coroutine.wrap(function()
        while true do
            sessionTime = tick() - ExperienceTracker.StartTime
            local hours = math.floor(sessionTime / 3600)
            local minutes = math.floor((sessionTime % 3600) / 60)
            local seconds = math.floor(sessionTime % 60)
            
            sessionTimer:SetText(string.format("Session Time: %02d:%02d:%02d", hours, minutes, seconds))
            task.wait(1)
        end
    end)()
    
    expTab:AddButton({
        Name = "Reset Experience Tracker",
        Callback = function()
            ExperienceTracker.StartLevel = GetPlayerLevel()
            ExperienceTracker.StartTime = tick()
            ExperienceTracker.LevelsGained = 0
            ExperienceTracker.ExperienceRate = 0
            ExperienceTracker.EstimatedTimeToNextLevel = 0
        end
    })
end

-- Auto Skill Level Detection
function DetectAvailableSkills()
    local availableSkills = {}
    
    -- Check inventory for skill items
    local backpack = Player:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                for skillName, skillData in pairs(LeviSkills) do
                    if item.Name:find(skillName) then
                        availableSkills[skillName] = true
                    end
                end
            end
        end
    end
    
    -- Check equipped skills
    if Character then
        for _, item in pairs(Character:GetChildren()) do
            if item:IsA("Tool") then
                for skillName, skillData in pairs(LeviSkills) do
                    if item.Name:find(skillName) then
                        availableSkills[skillName] = true
                    end
                end
            end
        end
    end
    
    return availableSkills
end

function AutoConfigureSkills()
    local availableSkills = DetectAvailableSkills()
    
    -- Enable available skills
    for skillName in pairs(availableSkills) do
        local settingName = "Use" .. skillName:gsub(" ", "")
        if Settings[settingName] ~= nil then
            Settings[settingName] = true
        end
    end
    
    -- Update UI
    UpdateSkillSettingsUI()
    
    Notify("Skills", "Auto-configured skills based on inventory", 3)
end

function UpdateSkillSettingsUI()
    -- This would update the skill toggles in the UI
    -- Implementation depends on OrionLib's API
end

-- Advanced Target Prioritization
function GetAdvancedTargetPriority(mob)
    local priority = 0
    
    -- Base priority
    priority = priority + 10
    
    -- Level difference (higher level = higher priority)
    local playerLevel = GetPlayerLevel()
    local mobLevel = mob:GetAttribute("Level") or 0
    local levelDiff = mobLevel - playerLevel
    
    if levelDiff > 0 then
        priority = priority + (levelDiff * 5) -- Higher level mobs get more priority
    else
        priority = priority + (levelDiff * 2) -- Lower level mobs get less priority
    end
    
    -- Health percentage (lower health = higher priority for finishing)
    local healthPercent = mob.Humanoid.Health / mob.Humanoid.MaxHealth
    priority = priority + ((1 - healthPercent) * 20)
    
    -- Distance (closer = higher priority)
    local distance = (HumanoidRootPart.Position - mob.HumanoidRootPart.Position).Magnitude
    priority = priority + (100 - math.min(distance, 100))
    
    -- Boss priority
    if mob.Name:find("Boss") or mob.Name:find("King") or mob.Name:find("Queen") then
        priority = priority + 100
    end
    
    -- Rare mob priority
    if mob.Name:find("Rare") or mob.Name:find("Elite") then
        priority = priority + 50
    end
    
    return priority
end

function GetBestTargetByPriority()
    local mobs = {}
    local playerPos = HumanoidRootPart.Position
    
    -- Collect mobs in range
    for _, mob in pairs(Workspace.Enemies:GetChildren()) do
        if mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
            local distance = (playerPos - mob.HumanoidRootPart.Position).Magnitude
            
            if distance <= Settings.FarmRange then
                local priority = GetAdvancedTargetPriority(mob)
                table.insert(mobs, {
                    Mob = mob,
                    Priority = priority,
                    Distance = distance
                })
            end
        end
    end
    
    -- Sort by priority (highest first)
    table.sort(mobs, function(a, b)
        return a.Priority > b.Priority
    end)
    
    return #mobs > 0 and mobs[1].Mob or nil
end

-- Initialize all advanced systems
function InitializeAdvancedSystems()
    -- Start experience tracking
    StartExperienceTracking()
    
    -- Initialize protection system
    InitializeProtectionSystem()
    
    -- Auto-configure skills
    if Settings.AutoSkillConfiguration then
        AutoConfigureSkills()
    end
    
    -- Create advanced UI tabs
    CreateFarmingRouteSystem()
    DisplayExperienceStats()
    DisplayCombatAnalytics()
    
    -- Load farming routes
    LoadFarmingRoutes()
    
    Notify("Advanced Systems", "All advanced systems initialized", 3)
end

-- Main initialization sequence
coroutine.wrap(function()
    task.wait(3) -- Wait for initial setup
    
    InitializeAdditionalSystems()
    InitializeAdvancedSystems()
    
    -- Final setup
    UpdatePlayerStatsDisplay()
    
    -- Enable anti-AFK
    if Settings.AntiAfk then
        EnableAntiAfk()
    end
    
    Notify("System", "Complete initialization finished", 3)
    Notify("System", "Ready for action!", 3)
end)()

-- Final cleanup and error handling
local FinalCleanup = function()
    -- Save all data
    if Settings.SaveSettings then
        SaveSettings()
    end
    
    SaveTeleportData()
    SavePresets()
    SaveFarmingRoutes()
    
    -- Cleanup all connections
    for _, connection in pairs(ESPObjects) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
    
    -- Destroy UI elements
    if Watermark then
        Watermark:Destroy()
    end
    
    -- Stop all loops
    if FarmLoop then FarmLoop:Disconnect() end
    if LeviLoop then LeviLoop:Disconnect() end
    if BoatLoop then BoatLoop:Disconnect() end
    if RaidLoop then RaidLoop:Disconnect() end
    if IslandLoop then IslandLoop:Disconnect() end
    
    Notify("System", "Script cleanup completed", 3)
end

-- Connect cleanup to game closing
game:BindToClose(FinalCleanup)

-- Keyboard shortcuts for quick access
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Quick skill triggers
    if input.KeyCode == Enum.KeyCode.F1 then
        UseLeviSkill("Levi Dash")
    elseif input.KeyCode == Enum.KeyCode.F2 then
        UseLeviSkill("Levi Spin")
    elseif input.KeyCode == Enum.KeyCode.F3 then
        UseLeviSkill("Levi Flight")
    elseif input.KeyCode == Enum.KeyCode.F4 then
        UseLeviSkill("Levi Vortex")
    elseif input.KeyCode == Enum.KeyCode.F5 then
        UseLeviSkill("Levi Tsunami")
    
    -- Quick toggles
    elseif input.KeyCode == Enum.KeyCode.F6 then
        Settings.AutoFarm = not Settings.AutoFarm
        Notify("Quick Toggle", "Auto Farm: " .. (Settings.AutoFarm and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F7 then
        Settings.AutoLevi = not Settings.AutoLevi
        Notify("Quick Toggle", "Auto Levi: " .. (Settings.AutoLevi and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F8 then
        Settings.AutoBoat = not
     
-- Continuing from corrected Part 7...

-- Keyboard shortcuts for quick access
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Quick skill triggers
    if input.KeyCode == Enum.KeyCode.F1 then
        UseLeviSkill("Levi Dash")
    elseif input.KeyCode == Enum.KeyCode.F2 then
        UseLeviSkill("Levi Spin")
    elseif input.KeyCode == Enum.KeyCode.F3 then
        UseLeviSkill("Levi Flight")
    elseif input.KeyCode == Enum.KeyCode.F4 then
        UseLeviSkill("Levi Vortex")
    elseif input.KeyCode == Enum.KeyCode.F5 then
        UseLeviSkill("Levi Tsunami")
    
    -- Quick toggles
    elseif input.KeyCode == Enum.KeyCode.F6 then
        Settings.AutoFarm = not Settings.AutoFarm
        Notify("Quick Toggle", "Auto Farm: " .. (Settings.AutoFarm and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F7 then
        Settings.AutoLevi = not Settings.AutoLevi
        Notify("Quick Toggle", "Auto Levi: " .. (Settings.AutoLevi and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F8 then
        Settings.AutoBoat = not Settings.AutoBoat
        Notify("Quick Toggle", "Auto Boat: " .. (Settings.AutoBoat and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F9 then
        Settings.AutoTikiIsland = not Settings.AutoTikiIsland
        Notify("Quick Toggle", "Auto Tiki Island: " .. (Settings.AutoTikiIsland and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F10 then
        Settings.AutoHydraIsland = not Settings.AutoHydraIsland
        Notify("Quick Toggle", "Auto Hydra Island: " .. (Settings.AutoHydraIsland and "ON" or "OFF"), 2)
    elseif input.KeyCode == Enum.KeyCode.F11 then
        Settings.AutoLeviRaid = not Settings.AutoLeviRaid
        Notify("Quick Toggle", "Auto Levi Raid: " .. (Settings.AutoLeviRaid and "ON" or "OFF"), 2)
    
    -- Quick actions
    elseif input.KeyCode == Enum.KeyCode.F12 then
        SpawnBoat()
    elseif input.KeyCode == Enum.KeyCode.P then
        EquipBestWeapon("Sword")
    elseif input.KeyCode == Enum.KeyCode.O then
        EquipBestWeapon("Fruit")
    elseif input.KeyCode == Enum.KeyCode.I then
        HumanoidRootPart.CFrame = CFrame.new(-1258, 18, 398) -- Teleport to starter island
    end
end)

-- Anti-AFK System Enhancement
function EnableAntiAfk()
    if not Settings.AntiAfk then return end
    
    -- Method 1: Virtual input
    local afkLoop = coroutine.wrap(function()
        while Settings.AntiAfk do
            -- Press random keys
            local keys = {"W", "A", "S", "D", "Space"}
            local randomKey = keys[math.random(1, #keys)]
            
            VirtualInputManager:SendKeyEvent(true, randomKey, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, randomKey, false, game)
            
            -- Random wait between 30-60 seconds
            task.wait(math.random(30, 60))
        end
    end)
    
    -- Method 2: Character movement
    local moveLoop = coroutine.wrap(function()
        while Settings.AntiAfk do
            -- Small random movement
            local randomDirection = Vector3.new(
                math.random(-10, 10),
                0,
                math.random(-10, 10)
            )
            
            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + randomDirection
            task.wait(math.random(45, 90))
        end
    end)
    
    -- Method 3: Roblox's built-in anti-idle
    local player = Players.LocalPlayer
    local connection = player.Idled:Connect(function()
        VirtualInputManager:SendKeyEvent(true, "Space", false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, "Space", false, game)
    end)
    
    table.insert(ESPObjects, connection)
    afkLoop()
    moveLoop()
    
    Notify("Anti-AFK", "Anti-AFK system enabled", 3)
end

-- Script Security and Anti-Detection
local Security = {
    RandomDelays = true,
    HumanLikeMovements = true,
    AvoidDetection = true,
    RandomActionVariations = true
}

function ApplySecurityMeasures()
    if Security.RandomDelays then
        ApplyRandomDelays()
    end
    
    if Security.HumanLikeMovements then
        EnableHumanLikeMovements()
    end
    
    if Security.AvoidDetection then
        SetupAntiDetection()
    end
end

function ApplyRandomDelays()
    -- Replace fixed delays with random ones
    local originalWait = task.wait
    task.wait = function(seconds)
        if seconds and type(seconds) == "number" then
            -- Add small random variation (+/- 20%)
            local variation = seconds * 0.2
            local randomDelay = seconds + (math.random() * variation * 2 - variation)
            return originalWait(math.max(0.1, randomDelay))
        end
        return originalWait(seconds)
    end
end

function EnableHumanLikeMovements()
    -- Add human-like imperfections to movements
    local originalCFrame = HumanoidRootPart.CFrame
    
    local movementModifier = RunService.Heartbeat:Connect(function()
        if not Security.HumanLikeMovements then return end
        
        -- Small random position variations
        local randomOffset = Vector3.new(
            (math.random() - 0.5) * 0.5,
            (math.random() - 0.5) * 0.2,
            (math.random() - 0.5) * 0.5
        )
        
        -- Apply with very small weight
        HumanoidRootPart.CFrame = HumanoidRootPart.CFrame:Lerp(
            HumanoidRootPart.CFrame + randomOffset,
            0.01
        )
    end)
    
    table.insert(ESPObjects, movementModifier)
end

function SetupAntiDetection()
    -- Hide script activities
    local hidden = true
    
    -- Randomize action patterns
    if Security.RandomActionVariations then
        RandomizeActionPatterns()
    end
    
    -- Disguise network traffic
    SetupNetworkDisguise()
end

function RandomizeActionPatterns()
    -- Add randomness to farming patterns
    local originalFarmTarget = FarmTarget
    FarmTarget = function(target)
        if not target then return end
        
        -- Random attack pattern selection
        local patterns = {
            function() originalFarmTarget(target) end,
            function() ExecuteSmartCombo(target) end,
            function() ExecuteAdvancedCombo(target) end
        }
        
        local selectedPattern = patterns[math.random(1, #patterns)]
        selectedPattern()
        
        -- Random delay between attacks
        task.wait(math.random(0.1, 0.3))
    end
end

function SetupNetworkDisguise()
    -- Simulate human-like network patterns
    -- Note: This is a conceptual implementation
    local function simulateNetworkActivity()
        while Security.AvoidDetection do
            -- Random network pings
            task.wait(math.random(5, 15))
            
            -- Simulate menu opens/closes
            if math.random(1, 10) == 1 then
                -- Random GUI interaction
                VirtualInputManager:SendKeyEvent(true, "Escape", false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, "Escape", false, game)
            end
        end
    end
    
    coroutine.wrap(simulateNetworkActivity)()
end

-- Performance Monitoring and Optimization
local Performance = {
    FPS = 60,
    Ping = 0,
    MemoryUsage = 0,
    LastOptimization = 0
}

function MonitorPerformance()
    coroutine.wrap(function()
        while true do
            -- Get FPS
            Performance.FPS = 1 / RunService.RenderStepped:Wait()
            
            -- Get ping
            Performance.Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            
            -- Estimate memory usage
            Performance.MemoryUsage = collectgarbage("count")
            
            -- Auto-optimize if performance drops
            if Performance.FPS < 30 and tick() - Performance.LastOptimization > 60 then
                OptimizePerformanceAutomatically()
                Performance.LastOptimization = tick()
            end
            
            task.wait(5)
        end
    end)()
end

function OptimizePerformanceAutomatically()
    Notify("Performance", "Auto-optimizing performance...", 3)
    
    -- Reduce graphics
    if not Settings.LowGraphics then
        Settings.LowGraphics = true
        EnableLowGraphics()
    end
    
    -- Reduce ESP if enabled
    if Settings.ESPEnabled then
        Settings.ESPMobs = false
        Settings.ESPPlayers = false
        EnableESP()
    end
    
    -- Clean up temporary objects
    CleanupTemporaryObjects()
    
    -- Reduce particle effects
    ReduceParticleEffects()
    
    Notify("Performance", "Performance optimized", 3)
end

function CleanupTemporaryObjects()
    -- Clean up temporary visual effects
    for _, effect in pairs(Workspace:GetDescendants()) do
        if effect:IsA("ParticleEmitter") and effect.Name:find("Temp") then
            effect:Destroy()
        end
    end
end

function ReduceParticleEffects()
    -- Reduce particle count
    for _, emitter in pairs(Workspace:GetDescendants()) do
        if emitter:IsA("ParticleEmitter") then
            emitter.Rate = math.floor(emitter.Rate * 0.5)
        end
    end
end

function DisplayPerformanceStats()
    local perfTab = Window:MakeTab({
        Name = "Performance",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    perfTab:AddSection({
        Name = "Current Stats"
    })
    
    local fpsLabel = perfTab:AddLabel("FPS: 60")
    local pingLabel = perfTab:AddLabel("Ping: 0 ms")
    local memoryLabel = perfTab:AddLabel("Memory: 0 MB")
    
    -- Update in real-time
    coroutine.wrap(function()
        while true do
            fpsLabel:SetText("FPS: " .. math.floor(Performance.FPS))
            pingLabel:SetText("Ping: " .. math.floor(Performance.Ping) .. " ms")
            memoryLabel:SetText("Memory: " .. string.format("%.1f", Performance.MemoryUsage / 1024) .. " MB")
            task.wait(2)
        end
    end)()
    
    perfTab:AddSection({
        Name = "Optimization"
    })
    
    perfTab:AddToggle({
        Name = "Auto-Optimize Performance",
        Default = true,
        Callback = function(Value)
            Settings.AutoOptimize = Value
        end
    })
    
    perfTab:AddButton({
        Name = "Force Optimize Now",
        Callback = function()
            OptimizePerformanceAutomatically()
        end
    })
    
    perfTab:AddButton({
        Name = "Clean Up Memory",
        Callback = function()
            collectgarbage("collect")
            Notify("Performance", "Memory cleaned up", 3)
        end
    })
end

-- Advanced Island Hopping System
local IslandSequence = {
    CurrentIsland = 1,
    Islands = {
        "Tiki Island",
        "Hydra Island", 
        "Shark Island",
        "Frozen Island",
        "Desert Island"
    },
    TimePerIsland = 600, -- 10 minutes per island
    IslandStartTime = 0
}

function StartIslandHopping()
    Settings.IslandHopping = true
    IslandSequence.IslandStartTime = tick()
    
    coroutine.wrap(function()
        while Settings.IslandHopping do
            local currentIsland = IslandSequence.Islands[IslandSequence.CurrentIsland]
            
            Notify("Island Hopping", "Traveling to: " .. currentIsland, 3)
            
            -- Travel to island
            local onIsland = TravelToIsland(currentIsland)
            
            if onIsland then
                -- Farm on island for configured time
                FarmOnIsland(currentIsland, IslandSequence.TimePerIsland)
            end
            
            -- Move to next island
            IslandSequence.CurrentIsland = IslandSequence.CurrentIsland + 1
            if IslandSequence.CurrentIsland > #IslandSequence.Islands then
                IslandSequence.CurrentIsland = 1
            end
            
            IslandSequence.IslandStartTime = tick()
        end
    end)()
    
    Notify("Island Hopping", "Island hopping started", 3)
end

function StopIslandHopping()
    Settings.IslandHopping = false
    Notify("Island Hopping", "Island hopping stopped", 3)
end

function TravelToIsland(islandName)
    -- Check if already on island
    local onIsland, currentIsland = IsPlayerInIsland()
    if onIsland and currentIsland == islandName then
        return true
    end
    
    -- Use boat to travel
    if not CurrentBoat then
        SpawnBoat()
        task.wait(3)
    end
    
    DriveBoatToIsland(islandName)
    
    -- Wait for arrival
    local timeout = 120 -- 2 minutes timeout
    local startTime = tick()
    
    while tick() - startTime < timeout do
        task.wait(2)
        
        onIsland, currentIsland = IsPlayerInIsland()
        if onIsland and currentIsland == islandName then
            return true
        end
    end
    
    Notify("Island Hopping", "Failed to reach " .. islandName, 3)
    return false
end

function FarmOnIsland(islandName, duration)
    local islandData = IslandLocations[islandName]
    if not islandData then return end
    
    local startTime = tick()
    
    Notify("Island Hopping", "Farming on " .. islandName .. " for " .. math.floor(duration/60) .. " minutes", 3)
    
    while tick() - startTime < duration and Settings.IslandHopping do
        -- Execute farming cycle
        ExecuteIslandFarmingCycle(islandName, islandData)
        
        -- Check if still on island
        local onIsland, currentIsland = IsPlayerInIsland()
        if not onIsland or currentIsland ~= islandName then
            Notify("Island Hopping", "Left " .. islandName .. " early", 3)
            break
        end
        
        task.wait(2)
    end
end

function CreateIslandHoppingSystem()
    local hoppingTab = Window:MakeTab({
        Name = "Island Hopping",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    hoppingTab:AddSection({
        Name = "Island Sequence"
    })
    
    -- Display current island sequence
    for i, islandName in ipairs(IslandSequence.Islands) do
        hoppingTab:AddLabel(i .. ". " .. islandName)
    end
    
    hoppingTab:AddSection({
        Name = "Configuration"
    })
    
    hoppingTab:AddSlider({
        Name = "Time per Island (minutes)",
        Min = 1,
        Max = 60,
        Default = 10,
        Color = Colors.Accent,
        Increment = 1,
        ValueName = "minutes",
        Callback = function(Value)
            IslandSequence.TimePerIsland = Value * 60
        end
    })
    
    hoppingTab:AddDropdown({
        Name = "Farming Mode",
        Default = "Mobs",
        Options = {"Mobs", "Boss", "Chests", "Resources", "All"},
        Callback = function(Value)
            Settings.IslandFarmMode = Value
        end
    })
    
    hoppingTab:AddSection({
        Name = "Control"
    })
    
    hoppingTab:AddToggle({
        Name = "Auto Island Hopping",
        Default = false,
        Callback = function(Value)
            Settings.IslandHopping = Value
            if Value then
                StartIslandHopping()
            else
                StopIslandHopping()
            end
        end
    })
    
    hoppingTab:AddButton({
        Name = "Start Island Hopping",
        Callback = function()
            StartIslandHopping()
        end
    })
    
    hoppingTab:AddButton({
        Name = "Skip to Next Island",
        Callback = function()
            SkipToNextIsland()
        end
    })
    
    hoppingTab:AddButton({
        Name = "Edit Island Sequence",
        Callback = function()
            EditIslandSequence()
        end
    })
end

function SkipToNextIsland()
    IslandSequence.CurrentIsland = IslandSequence.CurrentIsland + 1
    if IslandSequence.CurrentIsland > #IslandSequence.Islands then
        IslandSequence.CurrentIsland = 1
    end
    
    Notify("Island Hopping", "Skipping to: " .. IslandSequence.Islands[IslandSequence.CurrentIsland], 3)
end

function EditIslandSequence()
    local editWindow = OrionLib:MakeWindow({
        Name = "Edit Island Sequence",
        HidePremium = false,
        SaveConfig = false,
        ConfigFolder = "AstraHubIslandSequence"
    })
    
    local editTab = editWindow:MakeTab({
        Name = "Sequence Editor",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    editTab:AddSection({
        Name = "Current Sequence"
    })
    
    local sequenceItems = {}
    
    for i, islandName in ipairs(IslandSequence.Islands) do
        local item = editTab:AddLabel(i .. ". " .. islandName)
        table.insert(sequenceItems, {Label = item, Name = islandName})
    end
    
    editTab:AddSection({
        Name = "Edit Options"
    })
    
    editTab:AddButton({
        Name = "Move Island Up",
        Callback = function()
            MoveIslandInSequence(1)
            editWindow:Destroy()
            EditIslandSequence()
        end
    })
    
    editTab:AddButton({
        Name = "Move Island Down",
        Callback = function()
            MoveIslandInSequence(-1)
            editWindow:Destroy()
            EditIslandSequence()
        end
    })
    
    editTab:AddButton({
        Name = "Remove Island",
        Callback = function()
            RemoveIslandFromSequence()
            editWindow:Destroy()
            EditIslandSequence()
        end
    })
    
    editTab:AddButton({
        Name = "Add New Island",
        Callback = function()
            AddIslandToSequence()
            editWindow:Destroy()
            EditIslandSequence()
        end
    })
    
    editTab:AddSection({
        Name = "Save Changes"
    })
    
    editTab:AddButton({
        Name = "Save Sequence",
        Callback = function()
            SaveIslandSequence()
            editWindow:Destroy()
            Notify("Island Sequence", "Sequence saved", 3)
        end
    })
    
    editTab:AddButton({
        Name = "Cancel",
        Callback = function()
            editWindow:Destroy()
        end
    })
end

function MoveIslandInSequence(direction)
    -- This would move islands up/down in the sequence
    -- Implementation depends on UI selection system
end

function SaveIslandSequence()
    local success, errorMsg = pcall(function()
        local data = HttpService:JSONEncode(IslandSequence)
        writefile("AstraHub_IslandSequence.json", data)
    end)
    
    if not success then
        Notify("Island Sequence", "Failed to save sequence: " .. errorMsg, 3)
    end
end

function LoadIslandSequence()
    local success, errorMsg = pcall(function()
        if isfile("AstraHub_IslandSequence.json") then
            local data = readfile("AstraHub_IslandSequence.json")
            local loadedSequence = HttpService:JSONDecode(data)
            
            IslandSequence = loadedSequence
        end
    end)
    
    if not success then
        Notify("Island Sequence", "Failed to load sequence: " .. errorMsg, 3)
    end
end

-- Auto Skill Combo Generator
function GenerateOptimalCombo(target)
    if not target then return "" end
    
    local distance = (HumanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude
    local targetHealth = target.Humanoid.Health
    local maxHealth = target.Humanoid.MaxHealth
    local healthPercent = targetHealth / maxHealth
    
    local combo = ""
    
    if distance > 50 then
        -- Long range combo
        combo = "Levi Dash,Levi Flight,Levi Vortex,Levi Tsunami"
    elseif distance > 20 then
        -- Medium range combo
        if healthPercent > 0.5 then
            combo = "Levi Dash,Levi Spin,Levi Flight,Levi Vortex"
        else
            combo = "Levi Spin,Levi Vortex,Levi Dash,Levi Flight"
        end
    else
        -- Close range combo
        if healthPercent > 0.7 then
            combo = "Levi Spin,Levi Dash,Levi Flight"
        elseif healthPercent > 0.3 then
            combo = "Levi Vortex,Levi Spin,Levi Dash"
        else
            combo = "Levi Tsunami,Levi Vortex,Levi Spin"
        end
    end
    
    return combo
end

function AutoGenerateAndExecuteCombo(target)
    local combo = GenerateOptimalCombo(target)
    
    if combo ~= "" then
        ExecuteCombo(combo)
        return true
    end
    
    return false
end

-- Advanced Reward Tracking
local RewardTracker = {
    SessionStart = tick(),
    ItemsFound = {},
    BeliEarned = 0,
    ExperienceGained = 0,
    RareDrops = {}
}

function TrackRewards()
    local startBeli = GetPlayerBeli()
    local startLevel = GetPlayerLevel()
    
    coroutine.wrap(function()
        while true do
            -- Track beli earned
            local currentBeli = GetPlayerBeli()
            RewardTracker.BeliEarned = currentBeli - startBeli
            
            -- Track experience gained
            local currentLevel = GetPlayerLevel()
            RewardTracker.ExperienceGained = currentLevel - startLevel
            
            task.wait(10)
        end
    end)()
end

function RecordItemFound(itemName, rarity)
    if not RewardTracker.ItemsFound[itemName] then
        RewardTracker.ItemsFound[itemName] = 0
    end
    
    RewardTracker.ItemsFound[itemName] = RewardTracker.ItemsFound[itemName] + 1
    
    if rarity == "Rare" or rarity == "Legendary" then
        table.insert(RewardTracker.RareDrops, {
            Item = itemName,
            Time = os.date("%H:%M:%S"),
            Rarity = rarity
        })
        
        Notify("Rare Drop!", "Found " .. rarity .. ": " .. itemName, 5)
    end
end

function DisplayRewardStatistics()
    local rewardTab = Window:MakeTab({
        Name = "Rewards",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    rewardTab:AddSection({
        Name = "Session Statistics"
    })
    
    local beliLabel = rewardTab:AddLabel("Beli Earned: $" .. RewardTracker.BeliEarned)
    local expLabel = rewardTab:AddLabel("Levels Gained: " .. RewardTracker.ExperienceGained)
    
    -- Calculate session duration
    local sessionTime = tick() - RewardTracker.SessionStart
    local hours = math.floor(sessionTime / 3600)
    local minutes = math.floor((sessionTime % 3600) / 60)
    local timeLabel = rewardTab:AddLabel(string.format("Session Time: %02d:%02d", hours, minutes))
    
    rewardTab:AddSection({
        Name = "Items Found"
    })
    
    -- Display top 10 items
    local sortedItems = {}
    for itemName, count in pairs(RewardTracker.ItemsFound) do
        table.insert(sortedItems, {Name = itemName, Count = count})
    end
    
    table.sort(sortedItems, function(a, b)
        return a.Count > b.Count
    end)
    
    for i = 1, math.min(10, #sortedItems) do
        rewardTab:AddLabel(sortedItems[i].Name .. ": " .. sortedItems[i].Count)
    end
    
    rewardTab:AddSection({
        Name = "Rare Drops"
    })
    
    for i, drop in ipairs(RewardTracker.RareDrops) do
        rewardTab:AddLabel(drop.Time .. " - " .. drop.Item .. " (" .. drop.Rarity .. ")")
    end
    
    rewardTab:AddButton({
        Name = "Reset Session Stats",
        Callback = function()
            ResetRewardTracker()
            DisplayRewardStatistics()
        end
    })
    
    rewardTab:AddButton({
        Name = "Export Stats",
        Callback = function()
            ExportRewardStats()
        end
    })
end

function ResetRewardTracker()
    local currentBeli = GetPlayerBeli()
    local currentLevel = GetPlayerLevel()
    
    RewardTracker = {
        SessionStart = tick(),
        ItemsFound = {},
        BeliEarned = 0,
        ExperienceGained = 0,
        RareDrops = {}
    }
    
    Notify("Rewards", "Session statistics reset", 3)
end

function ExportRewardStats()
    local exportData = {
        Player = Player.Name,
        SessionStart = os.date("%Y-%m-%d %H:%M:%S", RewardTracker.SessionStart),
        SessionDuration = tick() - RewardTracker.SessionStart,
        BeliEarned = RewardTracker.BeliEarned,
        ExperienceGained = RewardTracker.ExperienceGained,
        ItemsFound = RewardTracker.ItemsFound,
        RareDrops = RewardTracker.RareDrops
    }
    
    local success, errorMsg = pcall(function()
        local jsonData = HttpService:JSONEncode(exportData)
        writefile("RewardStats_" .. os.date("%Y%m%d_%H%M%S") .. ".json", jsonData)
    end)
    
    if success then
        Notify("Rewards", "Statistics exported successfully", 3)
    else
        Notify("Rewards", "Export failed: " .. errorMsg, 3)
    end
end

-- Auto Configuration based on Time
function ApplyTimeBasedConfiguration()
    local currentHour = tonumber(os.date("%H"))
    
    if currentHour >= 0 and currentHour < 6 then
        -- Night time: stealth farming
        Settings.AutoFarm = true
        Settings.AutoLevi = false
        Settings.FarmRange = 300
        Settings.MobPriority = "Lowest Level"
        Notify("Auto Config", "Applied Night Mode configuration", 3)
        
    elseif currentHour >= 6 and currentHour < 12 then
        -- Morning: active farming
        Settings.AutoFarm = true
        Settings.AutoLevi = true
        Settings.FarmRange = 500
        Settings.MobPriority = "Highest Level"
        Notify("Auto Config", "Applied Morning Mode configuration", 3)
        
    elseif currentHour >= 12 and currentHour < 18 then
        -- Afternoon: boss hunting
        Settings.AutoFarm = true
        Settings.AutoLevi = true
        Settings.MobPriority = "Boss Priority"
        Notify("Auto Config", "Applied Afternoon Mode configuration", 3)
        
    else
        -- Evening: mixed activities
        Settings.AutoFarm = true
        Settings.AutoLevi = true
        Settings.AutoBoat = true
        Settings.AutoTikiIsland = true
        Notify("Auto Config", "Applied Evening Mode configuration", 3)
    end
    
    SaveSettings()
end

-- Initialize final systems
function InitializeFinalSystems()
    -- Apply security measures
    ApplySecurityMeasures()
    
    -- Start performance monitoring
    MonitorPerformance()
    
    -- Start reward tracking
    TrackRewards()
    
    -- Load island sequence
    LoadIslandSequence()
    
    -- Apply time-based configuration
    if Settings.TimeBasedConfig then
        ApplyTimeBasedConfiguration()
    end
    
    -- Create final UI tabs
    CreateIslandHoppingSystem()
    DisplayPerformanceStats()
    DisplayRewardStatistics()
    
    Notify("System", "Final systems initialized", 3)
end

-- Main execution with proper error handling
local function SafeInitialize()
    local success, error = pcall(function()
        -- Wait for game to fully load
        task.wait(5)
        
        -- Re-initialize character references
        Character = Player.Character or Player.CharacterAdded:Wait()
        HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        Humanoid = Character:WaitForChild("Humanoid")
        
        -- Initialize Orion UI
        OrionLib:Init()
        
        -- Initialize all systems in sequence
        InitializeAdditionalSystems()
        InitializeAdvancedSystems()
        InitializeFinalSystems()
        
        -- Update watermark with player info
        if WatermarkLabel then
            WatermarkLabel.Text = "âš¡ Astra Hub | " .. Player.Name .. " | Lvl: " .. GetPlayerLevel()
        end
        
        -- Final notification
        Notify("LoadingScripts ...", 5)
        Notify("Status", "LoadingScripts ...", 3)
        
        print("LoadingScripts ...")
        print("LoadingScripts ...")
        print("LoadingScripts ...")
        print("Player: " .. Player.Name)
        print("Level: " .. GetPlayerLevel())
        print("Beli: $" .. GetPlayerBeli())
        print("LoadingScripts ...")
    end)
    
    if not success then
        warn("Initialization error: " .. error)
        Notify("Error", "Initialization failed: " .. error, 10)
    end
end

-- Start safe initialization
coroutine.wrap(SafeInitialize)()

-- Final global functions for external access
_G.AstraHub = {
    Version = "5.0",
    Player = Player,
    Settings = Settings,
    
    -- Control functions
    StartFarming = function() 
        Settings.AutoFarm = true
        StartAutoFarm()
    end,
    
    StopFarming = function()
        Settings.AutoFarm = false
        StopAutoFarm()
    end,
    
    StartLeviSkills = function()
        Settings.AutoLevi = true
        StartLeviSkills()
    end,
    
    StopLeviSkills = function()
        Settings.AutoLevi = false
        StopLeviSkills()
    end,
    
    TeleportToIsland = function(islandName)
        if IslandLocations[islandName] then
            HumanoidRootPart.CFrame = CFrame.new(IslandLocations[islandName].Position)
            return true
        end
        return false
    end,
    
    GetPlayerStats = function()
        return {
            Level = GetPlayerLevel(),
            Beli = GetPlayerBeli(),
            Position = HumanoidRootPart.Position
        }
    end,
    
    -- Utility
    Notify = Notify,
    SaveAllSettings = function()
        SaveSettings()
        SaveTeleportData()
        SavePresets()
        SaveFarmingRoutes()
        SaveIslandSequence()
        Notify("System", "All settings saved", 3)
    end
}

-- Make AstraHub globally accessible
if not _G.AstraHubInitialized then
    _G.AstraHubInitialized = true
    Notify("System", "Astra Hub API loaded", 2)
end

-- Auto-save system
local lastAutoSave = tick()
local autoSaveInterval = 300 -- 5 minutes

coroutine.wrap(function()
    while true do
        if tick() - lastAutoSave >= autoSaveInterval then
            if Settings.SaveSettings then
                SaveSettings()
                lastAutoSave = tick()
                Notify("Auto-Save", "Settings auto-saved", 2)
            end
        end
        task.wait(30)
    end
end)()

-- Connection cleanup on script re-execution
if _G.AstraHubConnections then
    for _, connection in pairs(_G.AstraHubConnections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
end

_G.AstraHubConnections = ESPObjects

-- Final message
print("\n" .. string.rep("=", 50))
print("LoadingScripts ...")
print("LoadingScripts ...")
print("Player: " .. Player.Name)
print(string.rep("=", 50))
print("LoadingScripts 50%")
print("- Auto Farm System")
print("- Levi Skills System")
print("- Boat Navigation System")
print("- Island Farming System")
print("- Auto Buy System")
print("- Leviathan Raid System")
print("- Combat Analytics")
print("- Performance Monitoring")
print("- Reward Tracking")
print("- Island Hopping System")
print(string.rep("=", 50))
print("LoadingScripts ...")
print("F1-F5 for quick skills, F6-F11 for quick toggles")
print(string.rep("=", 50) .. "\n")

-- Script completed successfully
return "Astra Hub Levi loaded successfully"
-- Pháº§n 9: Há»‡ thá»‘ng cuá»‘i cÃ¹ng vÃ  tá»‘i Æ°u hÃ³a

-- Auto Team System
local TeamSystem = {
    AutoAcceptTeamInvites = false,
    AutoInviteFriends = false,
    TeamMembers = {},
    LastInviteTime = 0
}

function SetupTeamSystem()
    -- Listen for team invites
    if TeamSystem.AutoAcceptTeamInvites then
        StartAutoAcceptTeamInvites()
    end
    
    -- Auto invite friends
    if TeamSystem.AutoInviteFriends then
        StartAutoInviteFriends()
    end
end

function StartAutoAcceptTeamInvites()
    -- This would need to detect team invites from the game
    -- Implementation depends on game-specific events
    Notify("Team System", "Auto-accept team invites enabled", 3)
end

function StartAutoInviteFriends()
    coroutine.wrap(function()
        while TeamSystem.AutoInviteFriends do
            -- Get friends list
            local friends = Players:GetFriendsAsync(Player.UserId)
            
            for _, friend in pairs(friends) do
                if friend.IsOnline and friend.Username ~= Player.Name then
                    -- Send team invite
                    SendTeamInvite(friend.Username)
                    task.wait(2) -- Wait between invites
                end
            end
            
            task.wait(60) -- Check every minute
        end
    end)()
end

function SendTeamInvite(username)
    -- Simulate sending team invite
    Notify("Team System", "Invited " .. username .. " to team", 2)
end

-- Quick Skill Bind System
local SkillBinds = {
    ["MouseButton1"] = "Basic Attack",
    ["Q"] = "Levi Dash",
    ["E"] = "Levi Spin",
    ["R"] = "Levi Flight",
    ["T"] = "Levi Vortex",
    ["Y"] = "Levi Tsunami"
}

function SetupSkillBinds()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        local key = input.KeyCode.Name
        if SkillBinds[key] then
            local skillName = SkillBinds[key]
            if skillName == "Basic Attack" then
                VirtualInputManager:SendKeyEvent(true, "MouseButton1", false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, "MouseButton1", false, game)
            else
                UseLeviSkill(skillName)
            end
        end
    end)
end

-- Auto Potion System
local PotionSystem = {
    AutoUseHealthPotions = false,
    HealthThreshold = 30,
    AutoUseEnergyPotions = false,
    EnergyThreshold = 20,
    PotionCooldown = 30
}

function SetupPotionSystem()
    coroutine.wrap(function()
        while true do
            if PotionSystem.AutoUseHealthPotions then
                CheckAndUseHealthPotion()
            end
            
            if PotionSystem.AutoUseEnergyPotions then
                CheckAndUseEnergyPotion()
            end
            
            task.wait(2)
        end
    end)()
end

function CheckAndUseHealthPotion()
    if Humanoid.Health < (Humanoid.MaxHealth * (PotionSystem.HealthThreshold / 100)) then
        UseHealthPotion()
    end
end

function CheckAndUseEnergyPotion()
    -- Check energy level (would need game-specific implementation)
    local energyLow = false -- Placeholder
    
    if energyLow then
        UseEnergyPotion()
    end
end

function UseEnergyPotion()
    -- Look for energy potion in inventory
    local backpack = Player:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name:find("Potion") and item.Name:find("Energy") then
                Humanoid:EquipTool(item)
                task.wait(0.5)
                
                VirtualInputManager:SendKeyEvent(true, "E", false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, "E", false, game)
                
                Notify("Potion", "Used energy potion", 2)
                return true
            end
        end
    end
    return false
end

-- Auto Quest System
local QuestSystem = {
    AutoAcceptQuests = false,
    AutoCompleteQuests = false,
    CurrentQuests = {},
    QuestCheckInterval = 30
}

function SetupQuestSystem()
    if QuestSystem.AutoAcceptQuests then
        StartAutoAcceptQuests()
    end
    
    if QuestSystem.AutoCompleteQuests then
        StartAutoCompleteQuests()
    end
end

function StartAutoAcceptQuests()
    coroutine.wrap(function()
        while QuestSystem.AutoAcceptQuests do
            CheckForAvailableQuests()
            task.wait(QuestSystem.QuestCheckInterval)
        end
    end)()
end

function StartAutoCompleteQuests()
    coroutine.wrap(function()
        while QuestSystem.AutoCompleteQuests do
            CheckQuestCompletion()
            task.wait(QuestSystem.QuestCheckInterval)
        end
    end)()
end

function CheckForAvailableQuests()
    -- Look for quest NPCs
    for _, npc in pairs(Workspace.NPCs:GetChildren()) do
        if npc:FindFirstChild("QuestAvailable") then
            -- Teleport to NPC
            local originalPos = HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(npc.Position)
            task.wait(2)
            
            -- Accept quest
            if npc:FindFirstChild("Click") then
                fireclickdetector(npc.Click)
                Notify("Quest", "Accepted quest from " .. npc.Name, 3)
            end
            
            -- Return to original position
            HumanoidRootPart.CFrame = CFrame.new(originalPos)
        end
    end
end

function CheckQuestCompletion()
    -- Check if current quests are complete
    -- This would need game-specific implementation
end

-- Auto Sell Filter System
local SellFilter = {
    KeepRarityAbove = "Rare",
    KeepLevelAbove = 100,
    KeepSwords = true,
    KeepFruits = true,
    KeepAccessories = true
}

function SetupSellFilter()
    -- Apply sell filter to auto-sell system
    if Settings.AutoSell then
        ApplySellFilter()
    end
end

function ApplySellFilter()
    -- Scan inventory and mark items for selling based on filter
    local inventory = ScanInventory()
    
    -- Process swords
    if not SellFilter.KeepSwords then
        for _, sword in pairs(inventory.Swords) do
            MarkItemForSale(sword)
        end
    end
    
    -- Process fruits
    if not SellFilter.KeepFruits then
        for _, fruit in pairs(inventory.Fruits) do
            MarkItemForSale(fruit)
        end
    end
    
    -- Process accessories
    if not SellFilter.KeepAccessories then
        for _, accessory in pairs(inventory.Accessories) do
            MarkItemForSale(accessory)
        end
    end
end

-- Advanced Mob Radar System
local MobRadar = {
    Enabled = false,
    ScanRadius = 500,
    UpdateInterval = 5,
    MobTypes = {}
}

function EnableMobRadar()
    MobRadar.Enabled = true
    
    -- Create radar display
    CreateRadarDisplay()
    
    -- Start radar scanning
    StartRadarScanning()
end

function CreateRadarDisplay()
    local radarGui = Instance.new("ScreenGui")
    radarGui.Name = "MobRadar"
    radarGui.Parent = Player:WaitForChild("PlayerGui")
    
    local radarFrame = Instance.new("Frame")
    radarFrame.Size = UDim2.new(0, 300, 0, 300)
    radarFrame.Position = UDim2.new(1, -320, 0, 20)
    radarFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    radarFrame.BackgroundTransparency = 0.5
    radarFrame.BorderSizePixel = 2
    radarFrame.BorderColor3 = Color3.fromRGB(0, 255, 0)
    radarFrame.Parent = radarGui
    
    -- Radar points will be added here
end

function StartRadarScanning()
    coroutine.wrap(function()
        while MobRadar.Enabled do
            UpdateRadarDisplay()
            task.wait(MobRadar.UpdateInterval)
        end
    end)()
end

function UpdateRadarDisplay()
    -- Clear old radar points
    -- Add new points based on mob positions
end

-- Auto Config Backup System
local ConfigBackup = {
    AutoBackup = true,
    BackupInterval = 3600, -- 1 hour
    MaxBackups = 10
}

function SetupConfigBackup()
    if ConfigBackup.AutoBackup then
        StartAutoBackup()
    end
end

function StartAutoBackup()
    coroutine.wrap(function()
        while ConfigBackup.AutoBackup do
            CreateConfigBackup()
            task.wait(ConfigBackup.BackupInterval)
        end
    end)()
end

function CreateConfigBackup()
    local timestamp = os.date("%Y%m%d_%H%M%S")
    local backupName = "AstraHub_Backup_" .. timestamp .. ".json"
    
    local backupData = {
        Settings = Settings,
        SavedLocations = SavedLocations,
        PresetConfigs = PresetConfigs,
        FarmingRoutes = FarmingRoutes,
        IslandSequence = IslandSequence,
        BackupTime = timestamp
    }
    
    local success, errorMsg = pcall(function()
        local jsonData = HttpService:JSONEncode(backupData)
        writefile(backupName, jsonData)
    end)
    
    if success then
        CleanupOldBackups()
        Notify("Backup", "Configuration backup created", 2)
    else
        Notify("Backup", "Backup failed: " .. errorMsg, 3)
    end
end

function CleanupOldBackups()
    -- Keep only the newest MaxBackups files
    -- Implementation would list and delete old backup files
end

-- UI Quick Access Panel
function CreateQuickAccessPanel()
    local quickTab = Window:MakeTab({
        Name = "Quick Access",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    quickTab:AddSection({
        Name = "One-Click Actions"
    })
    
    -- Farming
    quickTab:AddButton({
        Name = "Start Farming Session",
        Callback = function()
            Settings.AutoFarm = true
            Settings.AutoAttack = true
            Settings.AutoLevi = true
            StartAutoFarm()
            StartLeviSkills()
            Notify("Quick", "Farming session started", 3)
        end
    })
    
    quickTab:AddButton({
        Name = "Stop All Activities",
        Callback = function()
            Settings.AutoFarm = false
            Settings.AutoLevi = false
            Settings.AutoBoat = false
            Settings.AutoTikiIsland = false
            Settings.AutoHydraIsland = false
            Settings.AutoLeviRaid = false
            Notify("Quick", "All activities stopped", 3)
        end
    })
    
    -- Island Travel
    quickTab:AddSection({
        Name = "Island Travel"
    })
    
    quickTab:AddButton({
        Name = "Go to Tiki Island",
        Callback = function()
            DriveBoatToIsland("Tiki Island")
        end
    })
    
    quickTab:AddButton({
        Name = "Go to Hydra Island",
        Callback = function()
            DriveBoatToIsland("Hydra Island")
        end
    })
    
    -- Equipment
    quickTab:AddSection({
        Name = "Equipment"
    })
    
    quickTab:AddButton({
        Name = "Equip Best Gear",
        Callback = function()
            EquipBestWeapon("Sword")
            task.wait(0.5)
            EquipBestWeapon("Fruit")
            Notify("Quick", "Best gear equipped", 3)
        end
    })
    
    quickTab:AddButton({
        Name = "Heal Character",
        Callback = function()
            Humanoid.Health = Humanoid.MaxHealth
            Notify("Quick", "Character healed", 2)
        end
    })
    
    -- System
    quickTab:AddSection({
        Name = "System"
    })
    
    quickTab:AddButton({
        Name = "Save All Configs",
        Callback = function()
            SaveSettings()
            SaveTeleportData()
            SavePresets()
            SaveFarmingRoutes()
            SaveIslandSequence()
            Notify("Quick", "All configurations saved", 3)
        end
    })
    
    quickTab:AddButton({
        Name = "Load All Configs",
        Callback = function()
            LoadSettings()
            LoadTeleportData()
            LoadPresets()
            LoadFarmingRoutes()
            LoadIslandSequence()
            Notify("Quick", "All configurations loaded", 3)
        end
    })
end

-- Script Update Checker
function CheckForScriptUpdates()
    local currentVersion = "5.0"
    local updateUrl = "https://raw.githubusercontent.com/your-repo/version.json"
    
    local success, response = pcall(function()
        return game:HttpGet(updateUrl)
    end)
    
    if success then
        local updateInfo = HttpService:JSONDecode(response)
        if updateInfo.version > currentVersion then
            Notify("UPDATE AVAILABLE", "Version " .. updateInfo.version .. " is available!", 10)
            Notify("Update Info", updateInfo.changelog, 10)
            
            -- Offer auto-update option
            if updateInfo.autoUpdateUrl then
                OfferAutoUpdate(updateInfo.autoUpdateUrl)
            end
        end
    end
end

function OfferAutoUpdate(updateUrl)
    local updateWindow = OrionLib:MakeWindow({
        Name = "Script Update",
        HidePremium = false,
        SaveConfig = false
    })
    
    local updateTab = updateWindow:MakeTab({
        Name = "Update Available",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    updateTab:AddSection({
        Name = "New Version Available"
    })
    
    updateTab:AddLabel("A new version of Astra Hub is available!")
    updateTab:AddLabel("Click Update to get the latest features.")
    
    updateTab:AddButton({
        Name = "Update Now",
        Callback = function()
            ExecuteUpdate(updateUrl)
            updateWindow:Destroy()
        end
    })
    
    updateTab:AddButton({
        Name = "Later",
        Callback = function()
            updateWindow:Destroy()
        end
    })
end

function ExecuteUpdate(updateUrl)
    Notify("Update", "Downloading update...", 3)
    
    local success, newScript = pcall(function()
        return game:HttpGet(updateUrl)
    end)
    
    if success then
        -- Save new script
        writefile("AstraHub_Updated.lua", newScript)
        Notify("Update", "Update downloaded! Re-execute new script.", 5)
    else
        Notify("Update", "Update failed: " .. newScript, 5)
    end
end

-- Emergency Stop System
function SetupEmergencyStop()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.End then
            EmergencyStop()
        end
    end)
end

function EmergencyStop()
    -- Stop all activities
    Settings.AutoFarm = false
    Settings.AutoLevi = false
    Settings.AutoBoat = false
    Settings.AutoTikiIsland = false
    Settings.AutoHydraIsland = false
    Settings.AutoLeviRaid = false
    
    -- Stop all loops
    if FarmLoop then FarmLoop:Disconnect() end
    if LeviLoop then LeviLoop:Disconnect() end
    if BoatLoop then BoatLoop:Disconnect() end
    if RaidLoop then RaidLoop:Disconnect() end
    if IslandLoop then IslandLoop:Disconnect() end
    
    -- Disable ESP
    DisableESP()
    
    -- Reset player stats to normal
    Humanoid.WalkSpeed = 16
    Humanoid.JumpPower = 50
    
    Notify("EMERGENCY STOP", "All activities stopped!", 5)
    Notify("Safety", "Script functions disabled", 3)
end

-- Performance Profiler
local Profiler = {
    Enabled = false,
    FunctionTimes = {},
    LastProfile = 0
}

function StartProfiling()
    Profiler.Enabled = true
    Profiler.FunctionTimes = {}
    Profiler.LastProfile = tick()
    
    -- Hook into major functions
    HookProfiling()
    
    Notify("Profiler", "Performance profiling started", 3)
end

function StopProfiling()
    Profiler.Enabled = false
    DisplayProfileResults()
end

function HookProfiling()
    -- Example of hooking a function
    local originalFarmTarget = FarmTarget
    FarmTarget = function(...)
        local startTime = tick()
        local result = originalFarmTarget(...)
        local endTime = tick()
        
        if Profiler.Enabled then
            local duration = endTime - startTime
            if not Profiler.FunctionTimes["FarmTarget"] then
                Profiler.FunctionTimes["FarmTarget"] = {Total = 0, Calls = 0}
            end
            Profiler.FunctionTimes["FarmTarget"].Total = Profiler.FunctionTimes["FarmTarget"].Total + duration
            Profiler.FunctionTimes["FarmTarget"].Calls = Profiler.FunctionTimes["FarmTarget"].Calls + 1
        end
        
        return result
    end
end

function DisplayProfileResults()
    local totalTime = tick() - Profiler.LastProfile
    
    print("\n=== PERFORMANCE PROFILE ===")
    print("Total profiling time: " .. string.format("%.2f", totalTime) .. "s")
    print("Function performance:")
    
    for funcName, data in pairs(Profiler.FunctionTimes) do
        local avgTime = data.Total / data.Calls
        local percentage = (data.Total / totalTime) * 100
        
        print(string.format("  %s: %d calls, avg %.4fs, total %.2fs (%.1f%%)",
            funcName, data.Calls, avgTime, data.Total, percentage))
    end
    print("===========================\n")
    
    Notify("Profiler", "Profile results printed to console", 3)
end

-- Final Initialization Function
function CompleteInitialization()
    -- Setup remaining systems
    SetupTeamSystem()
    SetupSkillBinds()
    SetupPotionSystem()
    SetupQuestSystem()
    SetupSellFilter()
    SetupConfigBackup()
    SetupEmergencyStop()
    
    -- Create final UI tabs
    CreateQuickAccessPanel()
    
    -- Check for updates
    if Settings.CheckForUpdates then
        CheckForScriptUpdates()
    end
    
    -- Apply final optimizations
    if Settings.AutoOptimize then
        OptimizePerformanceAutomatically()
    end
    
    -- Start profiling if enabled
    if Settings.EnableProfiling then
        StartProfiling()
    end
    
    -- Final status update
    Notify("System", "All systems operational", 3)
    Notify("Ready", "Script fully initialized and ready", 3)
    
    -- Print final summary
    print("\n" .. string.rep("=", 60))
    print("LoadingScripts ...")
    print("LoadingScripts ...")
    print(string.rep("=", 60))
    print("Active Systems:")
    print("âœ“ Auto Farming: " .. tostring(Settings.AutoFarm))
    print("âœ“ Levi Skills: " .. tostring(Settings.AutoLevi))
    print("âœ“ Boat System: " .. tostring(Settings.AutoBoat))
    print("âœ“ Island Farming: " .. tostring(Settings.AutoTikiIsland or Settings.AutoHydraIsland))
    print("âœ“ Raid System: " .. tostring(Settings.AutoLeviRaid))
    print("âœ“ ESP System: " .. tostring(Settings.ESPEnabled))
    print("âœ“ Performance Monitor: Active")
    print("âœ“ Reward Tracker: Active")
    print("âœ“ Security System: Active")
    print(string.rep("=", 60))
    print("Quick Controls:")
    print("F1-F5: Quick Skills")
    print("F6-F11: Feature Toggles")
    print("End: Emergency Stop")
    print("RightCtrl/Insert: Toggle UI")
    print(string.rep("=", 60))
    print("Player: " .. Player.Name)
    print("Level: " .. GetPlayerLevel())
    print("Beli: $" .. GetPlayerBeli())
    print("Session Start: " .. os.date("%H:%M:%S"))
    print(string.rep("=", 60) .. "\n")
    
    return true
end

-- Start complete initialization
coroutine.wrap(function()
    task.wait(2) -- Final wait
    CompleteInitialization()
end)()

-- Global cleanup on game close
game:BindToClose(function()
    -- Save everything
    if Settings.SaveSettings then
        SaveSettings()
        SaveTeleportData()
        SavePresets()
        SaveFarmingRoutes()
        SaveIslandSequence()
    end
    
    -- Stop profiling
    if Profiler.Enabled then
        StopProfiling()
    end
    
    -- Clean up all connections
    for _, connection in pairs(ESPObjects) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
    
    -- Destroy UI
    if OrionLib then
        OrionLib:Destroy()
    end
    
    -- Destroy watermark
    if Watermark then
        Watermark:Destroy()
    end
    
    print("Astra Hub - shutdown completed")
end)

-- Return success
return "Astra Hub Levi"
-- Pháº§n cuá»‘i cÃ¹ng: Tá»•ng há»£p, tá»‘i Æ°u vÃ  hoÃ n thiá»‡n

-- Tá»•ng há»£p táº¥t cáº£ cÃ¡c module vÃ  há»‡ thá»‘ng
local AllSystems = {
    "Auto Farm System",
    "Levi Skills System", 
    "Boat Navigation System",
    "Island Farming System",
    "Auto Buy System",
    "Leviathan Raid System",
    "Combat Analytics System",
    "Performance Monitor",
    "Reward Tracker",
    "Security System",
    "Team System",
    "Potion System",
    "Quest System",
    "Sell Filter System",
    "Config Backup System",
    "Update System",
    "Emergency Stop System",
    "Profiling System"
}

-- Há»‡ thá»‘ng quáº£n lÃ½ táº¥t cáº£ cÃ¡c module
local SystemManager = {
    Systems = {},
    Status = {},
    LastHealthCheck = tick()
}

function SystemManager.RegisterSystem(name, startFunc, stopFunc, dependencies)
    SystemManager.Systems[name] = {
        Start = startFunc,
        Stop = stopFunc,
        Dependencies = dependencies or {},
        Running = false
    }
end

function SystemManager.StartSystem(name)
    local system = SystemManager.Systems[name]
    if not system or system.Running then return false end
    
    -- Check dependencies
    for _, dep in pairs(system.Dependencies) do
        if not SystemManager.Systems[dep] or not SystemManager.Systems[dep].Running then
            Notify("System Manager", "Cannot start " .. name .. ": missing dependency " .. dep, 3)
            return false
        end
    end
    
    -- Start system
    local success, errorMsg = pcall(system.Start)
    if success then
        system.Running = true
        SystemManager.Status[name] = "Running"
        Notify("System Manager", name .. " started successfully", 2)
        return true
    else
        SystemManager.Status[name] = "Error: " .. errorMsg
        Notify("System Manager", "Failed to start " .. name .. ": " .. errorMsg, 3)
        return false
    end
end

function SystemManager.StopSystem(name)
    local system = SystemManager.Systems[name]
    if not system or not system.Running then return false end
    
    -- Stop system
    local success, errorMsg = pcall(system.Stop)
    if success then
        system.Running = false
        SystemManager.Status[name] = "Stopped"
        Notify("System Manager", name .. " stopped successfully", 2)
        return true
    else
        SystemManager.Status[name] = "Error stopping: " .. errorMsg
        Notify("System Manager", "Failed to stop " .. name .. ": " .. errorMsg, 3)
        return false
    end
end

function SystemManager.GetSystemStatus(name)
    return SystemManager.Status[name] or "Not Registered"
end

function SystemManager.GetAllStatus()
    local status = {}
    for name, system in pairs(SystemManager.Systems) do
        status[name] = {
            Running = system.Running,
            Status = SystemManager.Status[name] or "Unknown"
        }
    end
    return status
end

-- ÄÄƒng kÃ½ táº¥t cáº£ cÃ¡c há»‡ thá»‘ng
function RegisterAllSystems()
    -- Auto Farm System
    SystemManager.RegisterSystem("Auto Farm", 
        function() 
            Settings.AutoFarm = true
            StartAutoFarm()
        end,
        function()
            Settings.AutoFarm = false
            StopAutoFarm()
        end
    )
    
    -- Levi Skills System
    SystemManager.RegisterSystem("Levi Skills",
        function()
            Settings.AutoLevi = true
            StartLeviSkills()
        end,
        function()
            Settings.AutoLevi = false
            StopLeviSkills()
        end,
        {"Auto Farm"} -- Phá»¥ thuá»™c vÃ o Auto Farm
    )
    
    -- Boat Navigation System
    SystemManager.RegisterSystem("Boat Navigation",
        function()
            Settings.AutoBoat = true
            StartBoatNavigation()
        end,
        function()
            Settings.AutoBoat = false
            StopBoatNavigation()
        end
    )
    
    -- ThÃªm cÃ¡c há»‡ thá»‘ng khÃ¡c tÆ°Æ¡ng tá»±...
end

-- Táº¡o System Manager UI
function CreateSystemManagerUI()
    local managerTab = Window:MakeTab({
        Name = "System Manager",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    managerTab:AddSection({
        Name = "System Control"
    })
    
    -- Hiá»ƒn thá»‹ tráº¡ng thÃ¡i táº¥t cáº£ há»‡ thá»‘ng
    for systemName, systemData in pairs(SystemManager.Systems) do
        local statusLabel = managerTab:AddLabel(systemName .. ": " .. SystemManager.GetSystemStatus(systemName))
        
        local button = managerTab:AddButton({
            Name = systemData.Running and "Stop " .. systemName or "Start " .. systemName,
            Callback = function()
                if systemData.Running then
                    SystemManager.StopSystem(systemName)
                else
                    SystemManager.StartSystem(systemName)
                end
                task.wait(0.5)
                CreateSystemManagerUI() -- Refresh UI
            end
        })
    end
    
    managerTab:AddSection({
        Name = "Batch Operations"
    })
    
    managerTab:AddButton({
        Name = "Start All Systems",
        Callback = function()
            for name, _ in pairs(SystemManager.Systems) do
                SystemManager.StartSystem(name)
                task.wait(0.2)
            end
            task.wait(1)
            CreateSystemManagerUI()
        end
    })
    
    managerTab:AddButton({
        Name = "Stop All Systems",
        Callback = function()
            for name, _ in pairs(SystemManager.Systems) do
                SystemManager.StopSystem(name)
                task.wait(0.2)
            end
            task.wait(1)
            CreateSystemManagerUI()
        end
    })
    
    managerTab:AddButton({
        Name = "Restart All Systems",
        Callback = function()
            for name, _ in pairs(SystemManager.Systems) do
                SystemManager.StopSystem(name)
                task.wait(0.1)
            end
            task.wait(1)
            for name, _ in pairs(SystemManager.Systems) do
                SystemManager.StartSystem(name)
                task.wait(0.1)
            end
            task.wait(1)
            CreateSystemManagerUI()
        end
    })
    
    managerTab:AddSection({
        Name = "System Health"
    })
    
    local healthLabel = managerTab:AddLabel("Last Health Check: " .. os.date("%H:%M:%S"))
    
    managerTab:AddButton({
        Name = "Run Health Check",
        Callback = function()
            RunSystemHealthCheck()
            healthLabel:SetText("Last Health Check: " .. os.date("%H:%M:%S"))
        end
    })
end

function RunSystemHealthCheck()
    local issues = {}
    
    -- Kiá»ƒm tra tá»«ng há»‡ thá»‘ng
    for name, system in pairs(SystemManager.Systems) do
        if system.Running then
            -- Kiá»ƒm tra phá»¥ thuá»™c
            for _, dep in pairs(system.Dependencies) do
                if not SystemManager.Systems[dep].Running then
                    table.insert(issues, name .. " missing dependency: " .. dep)
                end
            end
        end
    end
    
    -- Kiá»ƒm tra tÃ i nguyÃªn game
    if not Workspace:FindFirstChild("Enemies") then
        table.insert(issues, "Enemies folder not found")
    end
    
    if not Workspace:FindFirstChild("NPCs") then
        table.insert(issues, "NPCs folder not found")
    end
    
    -- Hiá»ƒn thá»‹ káº¿t quáº£
    if #issues == 0 then
        Notify("Health Check", "All systems healthy", 3)
    else
        local message = "Found " .. #issues .. " issues:\n"
        for i, issue in ipairs(issues) do
            message = message .. i .. ". " .. issue .. "\n"
        end
        Notify("Health Check", message, 10)
    end
end

-- Tá»‘i Æ°u hÃ³a cuá»‘i cÃ¹ng
function ApplyFinalOptimizations()
    -- Tá»‘i Æ°u bá»™ nhá»›
    collectgarbage("collect")
    
    -- Tá»‘i Æ°u graphics náº¿u chÆ°a báº­t
    if not Settings.LowGraphics then
        EnableLowGraphics()
    end
    
    -- Giáº£m update frequency cho cÃ¡c há»‡ thá»‘ng khÃ´ng quan trá»ng
    OptimizeUpdateFrequencies()
    
    -- Clean up temporary objects
    CleanupTemporaryObjects()
    
    Notify("Optimization", "Final optimizations applied", 2)
end

function OptimizeUpdateFrequencies()
    -- TÄƒng khoáº£ng cÃ¡ch update cho cÃ¡c há»‡ thá»‘ng Ã­t quan trá»ng
    if FarmLoop then
        -- Farm system cÃ³ thá»ƒ update cháº­m hÆ¡n
    end
    
    if ESPEnabled then
        -- ESP cÃ³ thá»ƒ update má»—i 0.5s thay vÃ¬ má»—i frame
    end
end

-- Há»‡ thá»‘ng bÃ¡o cÃ¡o tá»± Ä‘á»™ng
local AutoReport = {
    Enabled = false,
    ReportInterval = 1800, -- 30 phÃºt
    LastReport = 0
}

function SetupAutoReport()
    if AutoReport.Enabled then
        StartAutoReporting()
    end
end

function StartAutoReporting()
    coroutine.wrap(function()
        while AutoReport.Enabled do
            if tick() - AutoReport.LastReport >= AutoReport.ReportInterval then
                GenerateAutoReport()
                AutoReport.LastReport = tick()
            end
            task.wait(60) -- Check má»—i phÃºt
        end
    end)()
end

function GenerateAutoReport()
    local report = {
        Time = os.date("%Y-%m-%d %H:%M:%S"),
        Player = Player.Name,
        Level = GetPlayerLevel(),
        Beli = GetPlayerBeli(),
        SessionTime = tick() - (RewardTracker.SessionStart or tick()),
        SystemsRunning = 0,
        Issues = {}
    }
    
    -- Äáº¿m há»‡ thá»‘ng Ä‘ang cháº¡y
    for _, system in pairs(SystemManager.Systems) do
        if system.Running then
            report.SystemsRunning = report.SystemsRunning + 1
        end
    end
    
    -- Kiá»ƒm tra váº¥n Ä‘á»
    if Humanoid.Health < Humanoid.MaxHealth * 0.3 then
        table.insert(report.Issues, "Low health: " .. math.floor(Humanoid.Health) .. "/" .. Humanoid.MaxHealth)
    end
    
    if Performance.FPS < 30 then
        table.insert(report.Issues, "Low FPS: " .. math.floor(Performance.FPS))
    end
    
    -- LÆ°u bÃ¡o cÃ¡o
    SaveReport(report)
    
    -- ThÃ´ng bÃ¡o tÃ³m táº¯t
    if #report.Issues > 0 then
        Notify("Auto Report", "Report generated. Issues: " .. #report.Issues, 3)
    end
end

function SaveReport(report)
    local success, errorMsg = pcall(function()
        local jsonData = HttpService:JSONEncode(report)
        local filename = "AstraHub_Report_" .. os.date("%Y%m%d_%H%M%S") .. ".json"
        writefile(filename, jsonData)
    end)
    
    if not success then
        warn("Failed to save report: " .. errorMsg)
    end
end

-- Há»‡ thá»‘ng khÃ´i phá»¥c sau lá»—i
local RecoverySystem = {
    MaxRetries = 3,
    RetryDelay = 5,
    ErrorLog = {}
}

function SetupRecoverySystem()
    -- Báº¯t lá»—i cho cÃ¡c hÃ m quan trá»ng
    SetupErrorHandling()
end

function SetupErrorHandling()
    -- Wrap cÃ¡c hÃ m quan trá»ng vá»›i error handling
    local importantFunctions = {
        "FarmTarget",
        "UseLeviSkill", 
        "DriveBoatToIsland",
        "AutoBuyItem",
        "ExecuteLeviathanRaidPhase"
    }
    
    for _, funcName in pairs(importantFunctions) do
        if _G[funcName] then
            local originalFunc = _G[funcName]
            _G[funcName] = function(...)
                local success, result = pcall(originalFunc, ...)
                if not success then
                    LogError(funcName, result)
                    AttemptRecovery(funcName)
                    return nil
                end
                return result
            end
        end
    end
end

function LogError(functionName, errorMessage)
    table.insert(RecoverySystem.ErrorLog, {
        Time = os.date("%H:%M:%S"),
        Function = functionName,
        Error = errorMessage
    })
    
    -- Giá»›i háº¡n log size
    if #RecoverySystem.ErrorLog > 100 then
        table.remove(RecoverySystem.ErrorLog, 1)
    end
end

function AttemptRecovery(functionName)
    Notify("Recovery", "Attempting to recover from error in " .. functionName, 3)
    
    -- CÃ¡c biá»‡n phÃ¡p khÃ´i phá»¥c tÃ¹y theo hÃ m
    if functionName == "FarmTarget" then
        -- Di chuyá»ƒn Ä‘áº¿n vá»‹ trÃ­ an toÃ n
        RetreatToSafeZone()
    elseif functionName == "DriveBoatToIsland" then
        -- Dá»«ng boat vÃ  thá»­ láº¡i
        if CurrentBoat then
            CurrentBoat.Main.Velocity = Vector3.new(0, 0, 0)
        end
        task.wait(RecoverySystem.RetryDelay)
    end
end

-- Táº¡o Recovery System UI
function CreateRecoveryUI()
    local recoveryTab = Window:MakeTab({
        Name = "Recovery & Logs",
        Icon = "http://www.roblox.com/asset/?id=6023426923",
        PremiumOnly = false
    })
    
    recoveryTab:AddSection({
        Name = "Error Log"
    })
    
    for i, error in ipairs(RecoverySystem.ErrorLog) do
        recoveryTab:AddLabel(i .. ". [" .. error.Time .. "] " .. error.Function .. ": " .. error.Error)
    end
    
    recoveryTab:AddSection({
        Name = "Recovery Tools"
    })
    
    recoveryTab:AddButton({
        Name = "Clear Error Log",
        Callback = function()
            RecoverySystem.ErrorLog = {}
            CreateRecoveryUI()
        end
    })
    
    recoveryTab:AddButton({
        Name = "Force Recovery",
        Callback = function()
            ForceFullRecovery()
        end
    })
    
    recoveryTab:AddButton({
        Name = "Export Error Log",
        Callback = function()
            ExportErrorLog()
        end
    })
end

function ForceFullRecovery()
    -- Dá»«ng táº¥t cáº£ há»‡ thá»‘ng
    for name, _ in pairs(SystemManager.Systems) do
        SystemManager.StopSystem(name)
    end
    
    -- Reset vá» tráº¡ng thÃ¡i an toÃ n
    HumanoidRootPart.CFrame = CFrame.new(-1258, 18, 398) -- Vá» starter island
    
    -- Reset player stats
    Humanoid.WalkSpeed = 16
    Humanoid.JumpPower = 50
    
    -- Clear temporary data
    CurrentBoat = nil
    SeaBeastTarget = nil
    
    Notify("Recovery", "Full recovery executed", 3)
    
    -- Khá»Ÿi Ä‘á»™ng láº¡i há»‡ thá»‘ng cÆ¡ báº£n
    task.wait(3)
    SystemManager.StartSystem("Auto Farm")
end

function ExportErrorLog()
    local exportData = {
        Player = Player.Name,
        ExportTime = os.date("%Y-%m-%d %H:%M:%S"),
        Errors = RecoverySystem.ErrorLog
    }
    
    local success, errorMsg = pcall(function()
        local jsonData = HttpService:JSONEncode(exportData)
        writefile("ErrorLog_" .. os.date("%Y%m%d_%H%M%S") .. ".json", jsonData)
    end)
    
    if success then
        Notify("Export", "Error log exported successfully", 3)
    else
        Notify("Export", "Export failed: " .. errorMsg, 3)
    end
end

-- Há»‡ thá»‘ng phÃ¢n tÃ­ch hiá»‡u suáº¥t nÃ¢ng cao
local AdvancedAnalytics = {
    PerformanceHistory = {},
    ResourceUsage = {},
    OptimizationSuggestions = {}
}

function CollectAdvancedAnalytics()
    coroutine.wrap(function()
        while true do
            local snapshot = {
                Time = tick(),
                FPS = Performance.FPS,
                Ping = Performance.Ping,
                Memory = Performance.MemoryUsage,
                SystemsRunning = 0
            }
            
            -- Äáº¿m há»‡ thá»‘ng Ä‘ang cháº¡y
            for _, system in pairs(SystemManager.Systems) do
                if system.Running then
                    snapshot.SystemsRunning = snapshot.SystemsRunning + 1
                end
            end
            
            -- LÆ°u snapshot
            table.insert(AdvancedAnalytics.PerformanceHistory, snapshot)
            
            -- Giá»›i háº¡n lá»‹ch sá»­
            if #AdvancedAnalytics.PerformanceHistory > 360 then -- 1 giá» náº¿u thu tháº­p má»—i 10s
                table.remove(AdvancedAnalytics.PerformanceHistory, 1)
            end
            
            -- PhÃ¢n tÃ­ch vÃ  Ä‘á» xuáº¥t tá»‘i Æ°u
            AnalyzePerformance()
            
            task.wait(10) -- Thu tháº­p má»—i 10 giÃ¢y
        end
    end)()
end

function AnalyzePerformance()
    if #AdvancedAnalytics.PerformanceHistory < 10 then return end
    
    local recentFPS = {}
    for i = math.max(1, #AdvancedAnalytics.PerformanceHistory - 9), #AdvancedAnalytics.PerformanceHistory do
        table.insert(recentFPS, AdvancedAnalytics.PerformanceHistory[i].FPS)
    end
    
    local avgFPS = 0
    for _, fps in pairs(recentFPS) do
        avgFPS = avgFPS + fps
    end
    avgFPS = avgFPS / #recentFPS
    
    -- Kiá»ƒm tra vÃ  Ä‘á» xuáº¥t
    AdvancedAnalytics.OptimizationSuggestions = {}
    
    if avgFPS < 30 then
        if Settings.ESPEnabled then
            table.insert(AdvancedAnalytics.OptimizationSuggestions, "Disable ESP to improve FPS")
        end
        
        if not Settings.LowGraphics then
            table.insert(AdvancedAnalytics.OptimizationSuggestions, "Enable Low Graphics mode")
        end
        
        if #SystemManager.Systems > 5 then
            table.insert(AdvancedAnalytics.OptimizationSuggestions, "Consider stopping non-essential systems")
        end
    end
    
    -- Hiá»ƒn thá»‹ Ä‘á» xuáº¥t náº¿u cÃ³
    if #AdvancedAnalytics.OptimizationSuggestions > 0 and math.random(1, 10) == 1 then
        ShowOptimizationSuggestions()
    end
end

function ShowOptimizationSuggestions()
    local message = "Performance suggestions:\n"
    for i, suggestion in ipairs(AdvancedAnalytics.OptimizationSuggestions) do
        message = message .. i .. ". " .. suggestion .. "\n"
    end
    
    Notify("Optimization", message, 5)
end

-- Tá»•ng há»£p táº¥t cáº£ cÃ¡c hÃ m khá»Ÿi táº¡o cuá»‘i cÃ¹ng
function FinalInitialization()
    -- ÄÄƒng kÃ½ táº¥t cáº£ há»‡ thá»‘ng
    RegisterAllSystems()
    
    -- Ãp dá»¥ng tá»‘i Æ°u hÃ³a cuá»‘i cÃ¹ng
    ApplyFinalOptimizations()
    
    -- Thiáº¿t láº­p System Manager
    CreateSystemManagerUI()
    
    -- Thiáº¿t láº­p Recovery System
    SetupRecoverySystem()
    CreateRecoveryUI()
    
    -- Báº¯t Ä‘áº§u thu tháº­p analytics
    CollectAdvancedAnalytics()
    
    -- Thiáº¿t láº­p auto report
    SetupAutoReport()
    
    -- Khá»Ÿi Ä‘á»™ng cÃ¡c há»‡ thá»‘ng cÆ¡ báº£n
    SystemManager.StartSystem("Auto Farm")
    SystemManager.StartSystem("Levi Skills")
    
    -- Cáº­p nháº­t watermark cuá»‘i cÃ¹ng
    if WatermarkLabel then
        WatermarkLabel.Text = string.format("âš¡ Astra Hub | %s | Lvl: %d | $%s | FPS: %d", 
            Player.Name, GetPlayerLevel(), GetPlayerBeli(), math.floor(Performance.FPS))
    end
    
    -- ThÃ´ng bÃ¡o hoÃ n táº¥t
    Notify("ASTRA HUB", "COMPLETELY INITIALIZED", 5)
    Notify("Status", "All systems ready for optimal performance", 3)
    
    -- In thÃ´ng tin tá»•ng há»£p
    PrintFinalSummary()
    
    return true
end

function PrintFinalSummary()
    print("\n" .. string.rep("=", 70))
    print("LoadingScripts ...")
    print("LoadingScripts ...")
    print(string.rep("=", 70))
    print("PLAYER INFORMATION:")
    print("  Name: " .. Player.Name)
    print("  Level: " .. GetPlayerLevel())
    print("  Beli: $" .. GetPlayerBeli())
    print("  Position: " .. string.format("%.0f, %.0f, %.0f", 
        HumanoidRootPart.Position.X, HumanoidRootPart.Position.Y, HumanoidRootPart.Position.Z))
    print()
    print("SYSTEM STATUS:")
    local runningCount = 0
    for name, system in pairs(SystemManager.Systems) do
        if system.Running then
            print("  âœ“ " .. name)
            runningCount = runningCount + 1
        else
            print("  âœ— " .. name)
        end
    end
    print()
    print("PERFORMANCE:")
    print("  FPS: " .. math.floor(Performance.FPS))
    print("  Ping: " .. math.floor(Performance.Ping) .. "ms")
    print("  Memory: " .. string.format("%.1f", Performance.MemoryUsage / 1024) .. "MB")
    print("  Systems Running: " .. runningCount .. "/" .. #AllSystems)
    print()
    print("QUICK CONTROLS:")
    print("  F1-F5: Quick Skills")
    print("  F6-F11: Toggle Features")
    print("  End: Emergency Stop")
    print("  RightCtrl/Insert: Toggle UI")
    print("  System Manager: Control all systems")
    print()
    print("SAFETY FEATURES:")
    print("  âœ“ Anti-Stuck System")
    print("  âœ“ Anti-Fall Protection")
    print("  âœ“ Auto Recovery System")
    print("  âœ“ Error Logging")
    print("  âœ“ Performance Monitoring")
    print(string.rep("=", 70))
    print("SCRIPT READY - HAPPY FARMING!")
    print(string.rep("=", 70) .. "\n")
end

-- Khá»Ÿi táº¡o cuá»‘i cÃ¹ng vá»›i error handling
local finalInitSuccess, finalInitError = pcall(FinalInitialization)
if not finalInitSuccess then
    warn("Final initialization failed: " .. finalInitError)
    Notify("ERROR", "Final initialization failed: " .. finalInitError, 10)
    
    -- Cá»‘ gáº¯ng khá»Ÿi Ä‘á»™ng cháº¿ Ä‘á»™ an toÃ n
    SafeModeInitialization()
end

function SafeModeInitialization()
    Notify("Safe Mode", "Starting in safe mode...", 3)
    
    -- Chá»‰ khá»Ÿi Ä‘á»™ng cÃ¡c há»‡ thá»‘ng cÆ¡ báº£n
    Settings.AutoFarm = true
    Settings.AutoAttack = true
    StartAutoFarm()
    
    -- VÃ´ hiá»‡u hÃ³a cÃ¡c tÃ­nh nÄƒng nÃ¢ng cao
    Settings.ESPEnabled = false
    Settings.AutoLeviRaid = false
    Settings.AutoTikiIsland = false
    Settings.AutoHydraIsland = false
    
    -- Äáº·t vá» tráº¡ng thÃ¡i an toÃ n
    Humanoid.WalkSpeed = 30
    Humanoid.JumpPower = 50
    
    Notify("Safe Mode", "Basic systems initialized", 3)
end

-- Hook Ä‘á»ƒ reload script
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Ctrl + R Ä‘á»ƒ reload script (chá»‰ debug)
    if input.KeyCode == Enum.KeyCode.R and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        Notify("Debug", "Script reload requested...", 3)
        task.wait(1)
        -- Thá»±c hiá»‡n reload (cáº§n executor há»— trá»£)
    end
end)

-- Final export to global
_G.AstraHub = _G.AstraHub or {}
_G.AstraHub.FullVersion = true
_G.AstraHub.Version = "5.0"
_G.AstraHub.SystemManager = SystemManager
_G.AstraHub.Performance = Performance
_G.AstraHub.Settings = Settings
_G.AstraHub.Player = Player

-- API functions for external access
_G.AstraHub.StartFarming = function() SystemManager.StartSystem("Auto Farm") end
_G.AstraHub.StopFarming = function() SystemManager.StopSystem("Auto Farm") end
_G.AstraHub.StartLeviSkills = function() SystemManager.StartSystem("Levi Skills") end
_G.AstraHub.StopLeviSkills = function() SystemManager.StopSystem("Levi Skills") end
_G.AstraHub.GetPlayerInfo = function() return {Level = GetPlayerLevel(), Beli = GetPlayerBeli()} end
_G.AstraHub.Teleport = function(x, y, z) HumanoidRootPart.CFrame = CFrame.new(x, y, z) end
_G.AstraHub.GetStatus = function() return SystemManager.GetAllStatus() end

-- Final message
print("\n" .. string.rep("*", 80))
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts ...")
print("LoadingScripts 100 %")
print(string.rep("*", 80))

-- HoÃ n thÃ nh
return {
    Success = true,
    Version = "1.0",
    Player = Player.Name,
    Message = "Astra Hub Levi",
    Features = #AllSystems,
    Status = "Operational"
}
